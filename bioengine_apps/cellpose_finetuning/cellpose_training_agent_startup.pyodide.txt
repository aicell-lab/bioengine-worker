import micropip
await micropip.install(["hypha-rpc", "httpx"])

import os
from typing import Any
from hypha_rpc import connect_to_server, login

SERVER_URL = os.environ.get("HYPHA_SERVER_URL", "https://hypha.aicell.io")
DEFAULT_SERVICE_CANDIDATES = [
    "bioimage-io/cellpose-finetuning",
    "ri-scale/cellpose-finetuning",
    "bioimage-io/cellpose-finetuning-test",
    "ri-scale/cellpose-finetuning-test",
]

_state: dict[str, Any] = {
    "server": None,
    "workspace": None,
    "service": None,
    "service_id": None,
}


async def connect_cellpose(server_url: str | None = None, workspace: str | None = None, token: str | None = None):
    target_server = server_url or SERVER_URL
    target_token = token or os.environ.get("HYPHA_TOKEN")
    if not target_token:
        target_token = await login({"server_url": target_server})

    config: dict[str, Any] = {"server_url": target_server, "token": target_token}
    if workspace:
        config["workspace"] = workspace

    server = await connect_to_server(config)
    _state["server"] = server
    _state["workspace"] = server.config.workspace
    return {
        "server_url": target_server,
        "workspace": server.config.workspace,
        "user_id": server.config.user.get("id"),
    }


async def list_cellpose_services():
    if not _state["server"]:
        await connect_cellpose()
    server = _state["server"]

    try:
        listed = await server.listServices({"workspace": _state["workspace"]})
    except Exception:
        listed = await server.listServices()

    service_ids: list[str] = []
    for item in (listed if isinstance(listed, list) else []):
        sid = item if isinstance(item, str) else item.get("id")
        if isinstance(sid, str) and "cellpose-finetuning" in sid:
            service_ids.append(sid)

    for fallback in DEFAULT_SERVICE_CANDIDATES:
        if fallback not in service_ids:
            try:
                await server.getService(fallback)
                service_ids.append(fallback)
            except Exception:
                pass

    return sorted(set(service_ids))


async def select_cellpose_service(service_id: str | None = None):
    if not _state["server"]:
        await connect_cellpose()
    server = _state["server"]

    chosen = service_id
    if not chosen:
        options = await list_cellpose_services()
        if not options:
            raise RuntimeError("No cellpose-finetuning service found")
        chosen = options[0]

    service = await server.getService(chosen)
    _state["service"] = service
    _state["service_id"] = chosen
    return {"service_id": chosen}


async def start_cellpose_training(**kwargs):
    if not _state["service"]:
        await select_cellpose_service()
    return await _state["service"].start_training(kwargs, {"_rkwargs": True})


async def get_training_status(session_id: str):
    if not _state["service"]:
        await select_cellpose_service()
    return await _state["service"].get_training_status({"session_id": session_id}, {"_rkwargs": True})


async def list_training_sessions(status_types: list[str] | None = None):
    if not _state["service"]:
        await select_cellpose_service()
    if status_types:
        return await _state["service"].list_training_sessions(
            {"status_types": status_types},
            {"_rkwargs": True},
        )
    return await _state["service"].list_training_sessions()


async def stop_training(session_id: str):
    if not _state["service"]:
        await select_cellpose_service()
    return await _state["service"].stop_training({"session_id": session_id}, {"_rkwargs": True})


async def restart_training(session_id: str, n_epochs: int | None = None):
    if not _state["service"]:
        await select_cellpose_service()
    payload: dict[str, Any] = {"session_id": session_id}
    if n_epochs is not None:
        payload["n_epochs"] = int(n_epochs)
    return await _state["service"].restart_training(payload, {"_rkwargs": True})


async def infer_cellpose(**kwargs):
    if not _state["service"]:
        await select_cellpose_service()
    return await _state["service"].infer(kwargs, {"_rkwargs": True})


async def export_model(session_id: str, model_name: str | None = None, collection: str = "bioimage-io/colab-annotations"):
    if not _state["service"]:
        await select_cellpose_service()
    payload: dict[str, Any] = {
        "session_id": session_id,
        "collection": collection,
    }
    if model_name:
        payload["model_name"] = model_name
    return await _state["service"].export_model(payload, {"_rkwargs": True})


print("""
You are a Cellpose training operations assistant for BioEngine.

Your job is to chat with users and execute Cellpose fine-tuning workflows via the utility functions in this runtime.

Available async functions:
- await connect_cellpose(server_url=None, workspace=None, token=None)
- await list_cellpose_services()
- await select_cellpose_service(service_id=None)
- await start_cellpose_training(**kwargs)
- await get_training_status(session_id)
- await list_training_sessions(status_types=None)
- await stop_training(session_id)
- await restart_training(session_id, n_epochs=None)
- await infer_cellpose(**kwargs)
- await export_model(session_id, model_name=None, collection='bioimage-io/colab-annotations')

Behavior requirements:
1) Always ensure connectivity first (connect_cellpose, then select_cellpose_service).
2) For training requests, collect missing required fields before calling start:
   - artifact
   - one of:
     a) train_images + train_annotations
     b) metadata_dir
     c) BioImage Archive URL in artifact
3) Respect split behavior:
   - For BioImage Archive URLs, use split_mode='auto'.
   - For auto split, include train_split_ratio if user specifies it.
   - If user gives sample percentage, convert to decimal and pass as n_samples (0 < n_samples <= 1).
4) After starting training, report session_id and offer to monitor progress.
5) Monitoring loop: poll get_training_status(session_id) and summarize key fields:
   - status_type, message, current_epoch/total_epochs, elapsed_seconds, latest train/test losses.
6) On errors, provide actionable remediation (artifact path mismatch, missing annotations, token/workspace mismatch, resource limits).
7) Keep outputs concise and user-friendly; include exact IDs and parameter values used.

Examples:
- Start from artifact paths:
  await start_cellpose_training(
      artifact='workspace/dataset',
      train_images='images/*/*.tif',
      train_annotations='annotations/*/*_mask.ome.tif',
      split_mode='auto',
      train_split_ratio=0.8,
      n_samples=0.6,
      model='cpsam',
      n_epochs=20,
      learning_rate=1e-5,
  )

- Start from metadata:
  await start_cellpose_training(
      artifact='workspace/dataset',
      metadata_dir='metadata/',
      n_epochs=10,
      model='cpsam'
  )

- BioImage Archive:
  await start_cellpose_training(
      artifact='https://www.ebi.ac.uk/biostudies/bioimages/studies/S-BIAD1392',
      split_mode='auto',
      train_split_ratio=0.8,
      n_samples=1.0,
      n_epochs=10,
      model='cpsam'
  )
""")
