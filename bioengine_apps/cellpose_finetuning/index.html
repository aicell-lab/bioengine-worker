<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cellpose Fine-Tuning UI</title>
    <!-- Favicon to prevent 404 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§¬</text></svg>">
    
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hypha-rpc@0.20.30/dist/hypha-rpc-websocket.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.3/dist-browser/geotiff.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#1e293b',
                            900: '#0f172a',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', system-ui, -apple-system, sans-serif; }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s ease; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        /* Custom scrollbar for log area */
        .log-area::-webkit-scrollbar { width: 8px; }
        .log-area::-webkit-scrollbar-track { background-color: #0f172a; }
        .log-area::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 4px; }
    </style>
</head>
<body class="bg-gray-100 text-slate-800 min-h-screen flex flex-col">
    <div id="app" class="flex flex-col h-screen overflow-hidden">
        
        <!-- Top Navigation Bar -->
        <header class="bg-white border-b border-gray-200 z-10 flex-none h-16 flex items-center justify-between px-6 shadow-sm">
            <div class="flex items-center gap-3">
                <div class="bg-blue-600 text-white p-2 rounded-lg shadow-sm">
                    <i class="fas fa-search-plus"></i>
                </div>
                <div>
                    <h1 class="font-bold text-lg text-slate-800 leading-tight">Cellpose Fine-Tuning</h1>
                    <div class="text-xs text-slate-500 font-medium flex items-center gap-1">
                        <span v-if="isConnected" class="text-green-600 flex items-center gap-1"><i class="fas fa-circle text-[8px]"></i> Connected</span>
                        <span v-else class="text-red-500 flex items-center gap-1"><i class="fas fa-circle text-[8px]"></i> Disconnected</span>
                        <span v-if="isConnected" class="opacity-75">â€¢ [[ workspace ]]</span>
                    </div>
                </div>
            </div>

            <div class="flex items-center gap-4">
                <!-- Connection Controls -->
                <div v-if="!isConnected" class="flex items-center gap-2 bg-gray-50 p-1.5 rounded-lg border border-gray-200">
                    <input v-model="serverUrl" placeholder="Server URL" class="bg-transparent border-none text-sm focus:ring-0 px-2 w-48 placeholder-gray-400">
                    <button @click="login" :disabled="isConnecting" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded-md text-sm font-medium transition flex items-center gap-2">
                        <i class="fas fa-sign-in-alt"></i>
                        <span>Login</span>
                    </button>
                    <button @click="connect" :disabled="isConnecting" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded-md text-sm font-medium transition flex items-center gap-2">
                        <i v-if="isConnecting" class="fas fa-circle-notch fa-spin"></i>
                        <span v-text="isConnecting ? 'Connecting...' : 'Connect'"></span>
                    </button>
                    <button @click="showTokenInput = !showTokenInput" class="text-gray-400 hover:text-gray-600 px-2" title="Settings">
                        <i class="fas fa-cog"></i>
                    </button>
                </div>
                <div v-if="showTokenInput && !isConnected" class="absolute top-16 right-6 bg-white p-4 shadow-xl rounded-lg border border-gray-200 w-72 z-50">
                    <label class="block text-xs font-semibold text-gray-500 mb-1">Auth Token (Optional)</label>
                    <input v-model="authToken" type="password" class="w-full border rounded px-3 py-2 text-sm mb-2" placeholder="Token...">
                </div>

                <!-- Service Selection -->
                <div v-if="isConnected" class="flex items-center gap-3">
                    <!-- Only show selector if no service is active OR we have multiple options and want to switch -->
                    <div v-if="!service" class="flex items-center gap-2 bg-slate-50 px-3 py-1.5 rounded-lg border border-slate-200">
                        <i class="fas fa-server text-slate-400 text-xs"></i>
                        <select v-model="selectedServiceId" class="bg-transparent border-none text-sm focus:ring-0 w-48 font-medium">
                            <option value="" disabled>Select Service</option>
                            <option v-for="id in availableServices" :key="id" :value="id">[[ id ]]</option>
                        </select>
                        <button @click="listServices" class="text-slate-400 hover:text-blue-600 transition" title="Refresh Services">
                            <i class="fas fa-sync-alt" :class="{'fa-spin': isScanning}"></i>
                        </button>
                    </div>
                    
                    <div v-else class="flex items-center gap-2 bg-green-50 px-3 py-1.5 rounded-lg border border-green-200 text-green-800 text-sm font-medium">
                        <i class="fas fa-check-circle"></i> [[ selectedServiceId ]]
                    </div>

                    <button @click="disconnect" class="text-slate-500 hover:text-red-600 text-sm font-medium p-2 rounded-lg hover:bg-red-50 transition" title="Disconnect">
                        <i class="fas fa-power-off"></i>
                    </button>
                </div>
            </div>
        </header>

        <main class="flex-grow flex overflow-hidden">
            
            <transition name="fade">
                <div v-if="syncError" class="fixed bottom-4 left-4 z-50 bg-red-800 text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-3 max-w-sm">
                    <i class="fas fa-wifi"></i>
                    <div class="text-xs">
                        <div class="font-bold">Connection Issue</div>
                        <div>[[ syncError ]]</div>
                    </div>
                    <button @click="syncError = null" class="ml-2 text-white/50 hover:text-white"><i class="fas fa-times"></i></button>
                </div>
            </transition>

            <!-- Sidebar -->
            <transition name="fade">
                <aside v-if="isConnected && service" class="w-64 bg-slate-850 text-slate-300 flex-none flex flex-col justify-between">
                    <div>
                        <div class="p-6">
                            <div class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-4">Menu</div>
                            <nav class="space-y-1">
                                <button v-for="tab in tabs" :key="tab.id"
                                    @click="currentTab = tab.id"
                                    :class="currentTab === tab.id ? 'bg-blue-600 text-white shadow-lg shadow-blue-900/50' : 'hover:bg-slate-800 hover:text-white'"
                                    class="w-full text-left px-4 py-3 rounded-lg flex items-center gap-3 transition-all duration-200 font-medium">
                                    <i :class="tab.icon" class="w-5 text-center"></i> [[ tab.name ]]
                                </button>
                            </nav>
                        </div>
                    </div>

                    <!-- Active Session Widget -->
                    <div v-if="monitoredSession" class="bg-slate-900 p-6 border-t border-slate-800 relative group">
                        <button @click="monitoringSessionId = null" class="absolute top-2 right-2 text-slate-600 hover:text-slate-400 opacity-0 group-hover:opacity-100 transition">
                            <i class="fas fa-times"></i>
                        </button>
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider">
                                [[ monitoredSession.status_type === 'running' ? 'Active Training' : 'Training Status' ]]
                            </h3>
                            <span class="w-2 h-2 rounded-full transition-colors duration-300"
                                  :class="{
                                      'bg-green-500 animate-pulse': monitoredSession.status_type === 'running',
                                      'bg-green-600': monitoredSession.status_type === 'completed',
                                      'bg-red-500': monitoredSession.status_type === 'failed',
                                      'bg-gray-500': monitoredSession.status_type === 'stopped' || monitoredSession.status_type === 'waiting'
                                  }"></span>
                        </div>
                        <div class="bg-slate-800 rounded-lg p-3 border border-slate-700 transition-colors duration-300" 
                             :class="{'border-red-500/50': monitoredSession.status_type === 'failed'}">
                            <div class="flex justify-between items-center mb-1">
                                <span class="text-white text-sm font-mono font-bold">[[ monitoringSessionId.slice(0, 8) ]]...</span>
                                <span class="text-xs px-1.5 py-0.5 rounded capitalize" 
                                      :class="{
                                          'bg-blue-900 text-blue-300': monitoredSession.status_type === 'running',
                                          'bg-green-900 text-green-300': monitoredSession.status_type === 'completed',
                                          'bg-red-900 text-red-300': monitoredSession.status_type === 'failed',
                                          'bg-gray-700 text-gray-300': monitoredSession.status_type === 'stopped' || monitoredSession.status_type === 'waiting'
                                      }">
                                    [[ monitoredSession.status_type || 'Run' ]]
                                </span>
                            </div>
                            
                            <div v-if="monitoredSession.status_type !== 'failed'" class="w-full bg-slate-700 rounded-full h-1.5 mt-2 mb-1">
                                <div class="bg-blue-500 h-1.5 rounded-full transition-all duration-500" 
                                     :style="{ width: ((monitoredSession.current_epoch || 0) / (monitoredSession.total_epochs || 1) * 100) + '%' }"></div>
                            </div>
                            <div v-if="monitoredSession.status_type !== 'failed'" class="flex justify-between text-[10px] text-slate-400">
                                <span>Epoch [[ monitoredSession.current_epoch || 0 ]]</span>
                                <span>[[ monitoredSession.total_epochs || '?' ]] Total</span>
                            </div>

                            <div v-if="monitoredSession.status_type === 'failed'" class="mt-2 text-[10px] text-red-300 leading-tight">
                                [[ monitoredSession.message ]]
                            </div>
                        </div>
                    </div>
                </aside>
            </transition>

            <!-- Main Content Area -->
            <div class="flex-grow bg-gray-50 overflow-auto p-8">
                
                <!-- Not Connected / No Service State -->
                <div v-if="!isConnected || !service" class="h-full flex items-center justify-center">
                    <div class="max-w-md text-center">
                        <div class="inline-flex items-center justify-center w-20 h-20 bg-white rounded-2xl shadow-sm mb-6 text-4xl">ðŸ§¬</div>
                        <h2 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Cellpose Fine-Tuning</h2>
                        <p class="text-gray-500 mb-8" v-if="!isConnected">Connect to a Hypha server to manage your training sessions.</p>
                        <p class="text-gray-500 mb-8" v-else>Select a Cellpose Fine-Tuning Service to continue.</p>
                        
                        <div v-if="isConnected && availableServices.length === 0 && !isScanning" class="bg-orange-50 text-orange-800 p-4 rounded-lg text-sm mb-4">
                            <i class="fas fa-exclamation-triangle mr-2"></i> No services found in workspace "[[ workspace ]]".
                            <br>Make sure the Worker is running and you are logged into the correct workspace.
                        </div>

                        <div v-if="!isConnected && autoConnectError" class="bg-red-50 text-red-800 p-4 rounded-lg text-sm mb-4">
                             [[ autoConnectError ]]
                        </div>

                         <button v-if="isConnected && !service" @click="listServices" class="text-blue-600 hover:text-blue-800 font-medium">
                            <i class="fas fa-sync-alt mr-1"></i> Scan Again
                        </button>
                    </div>
                </div>

                <!-- Dashboard Tab -->
                <div v-if="service && currentTab === 'dashboard'" class="max-w-6xl mx-auto space-y-6 fade-enter-active">
                     <div class="flex justify-between items-end">
                        <h2 class="text-2xl font-bold text-gray-900">Dashboard</h2>
                        <div v-if="syncError" class="text-red-500 text-sm px-4 py-1 bg-red-50 rounded-full border border-red-200 flex items-center" title="Connection to worker is unstable">
                            <i class="fas fa-exclamation-triangle mr-2"></i> [[ syncError ]]
                        </div>
                        <button @click="refreshSessions(false)" class="text-gray-500 hover:text-blue-600 transition text-sm font-medium bg-white px-3 py-1.5 rounded-lg border border-gray-200 shadow-sm">
                            <i class="fas fa-sync-alt mr-1" :class="{'fa-spin': refreshLoading}"></i> Refresh
                        </button>
                    </div>

                    <div class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                         <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50/50">
                                <tr>
                                    <th class="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Session ID</th>
                                    <th class="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Status</th>
                                    <th class="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Progress</th>
                                    <th class="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Metrics (Loss)</th>
                                    <th class="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Created</th>
                                    <th class="px-6 py-3 text-right text-xs font-semibold text-gray-500 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr v-for="(session, id) in sessions" :key="id" class="hover:bg-slate-50 transition-colors cursor-pointer group" @click="viewSession(id)">
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="flex items-center">
                                            <span class="font-mono text-sm text-blue-600 font-medium group-hover:underline">[[ id.slice(0, 8) ]]</span>
                                        </div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span class="px-2.5 py-0.5 inline-flex text-xs font-medium rounded-full capitalize" 
                                              :class="{
                                                  'bg-green-100 text-green-800': session.status_type === 'completed',
                                                  'bg-blue-100 text-blue-800': session.status_type === 'running',
                                                  'bg-red-100 text-red-800': session.status_type === 'failed',
                                                  'bg-gray-100 text-gray-800': session.status_type === 'waiting' || session.status_type === 'stopped'
                                              }">
                                            [[ session.status_type ]]
                                        </span>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                         <div v-if="session.total_epochs">
                                            <div class="flex justify-between mb-1 text-xs"><span>[[ session.current_epoch || 0 ]]</span><span>[[ session.total_epochs ]]</span></div>
                                            <div class="w-24 bg-gray-200 rounded-full h-1.5">
                                                <div class="bg-blue-500 h-1.5 rounded-full" :style="{ width: ((session.current_epoch || 0) / session.total_epochs * 100) + '%' }"></div>
                                            </div>
                                         </div>
                                         <span v-else>-</span>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                        [[ getLatestLoss(session) ]]
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                        [[ formatDate(session.start_time) ]]
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium" @click.stop>
                                         <button @click="viewSession(id)" class="text-blue-600 hover:text-blue-900 mr-3">Details</button>
                                         <button v-if="session.status_type === 'running'" @click="stopTraining(id)" class="text-red-600 hover:text-red-900">Stop</button>
                                    </td>
                                </tr>
                                <tr v-if="Object.keys(sessions).length === 0">
                                    <td colspan="6" class="px-6 py-12 text-center text-gray-500 bg-gray-50 rounded-b-xl">
                                        <div class="text-4xl mb-2">ðŸ“­</div>
                                        <p>No training sessions found.</p>
                                        <button @click="currentTab = 'training'" class="mt-4 text-blue-600 font-medium hover:underline">Start a new training session</button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Training Form Tab -->
                <div v-if="service && currentTab === 'training'" class="max-w-4xl mx-auto">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl font-bold text-gray-900">New Training Session</h2>
                    </div>

                     <form @submit.prevent="startTraining" class="space-y-6">
                        
                         <!-- Card: Dataset -->
                         <div class="bg-white p-6 rounded-xl shadow-sm border border-gray-200">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-lg font-semibold text-gray-800 flex items-center gap-2"><i class="fas fa-database text-gray-400"></i> Dataset & Model</h3>
                            </div>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="md:col-span-2">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Dataset Source</label>
                                    <div class="relative">
                                        <i class="fas fa-database absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs pointer-events-none"></i>
                                        <select v-model="trainingParams.dataset_source" class="w-full appearance-none bg-white border border-gray-300 rounded-lg pl-9 pr-9 py-2.5 text-sm font-medium text-gray-700 shadow-sm hover:border-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
                                            <option value="Artifact">Artifact</option>
                                            <option value="Upload">Upload</option>
                                            <option value="BioImage Archive">BioImage Archive</option>
                                        </select>
                                        <i class="fas fa-chevron-down absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs pointer-events-none"></i>
                                    </div>
                                </div>
                                
                                <div v-if="trainingParams.dataset_source === 'Artifact'">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Artifact ID <span class="text-red-500">*</span></label>
                                    <div class="space-y-1">
                                        <div class="flex gap-2 relative">
                                            <input 
                                                v-model="trainingParams.artifact_input" 
                                                @input="handleArtifactInput"
                                                @focus="handleArtifactInput"
                                                @blur="closeSuggestions"
                                                @keydown.tab.prevent="acceptSuggestion"
                                                required 
                                                :class="[
                                                    'flex-grow rounded-lg px-3 py-2 text-sm outline-none transition border focus:ring-2',
                                                    artifactInputError
                                                        ? 'bg-red-50 border-red-500 text-red-700 placeholder-red-300 focus:border-red-500 focus:ring-red-300'
                                                        : 'bg-gray-50 border-gray-300 focus:border-blue-500 focus:ring-blue-500'
                                                ]"
                                                placeholder="workspace/dataset-alias"
                                            >
                                            <button type="button" @click="openFileBrowser" :disabled="artifactLookupPending || !artifactIdExists" :class="[
                                                'px-3 py-2 border rounded-lg transition',
                                                (artifactLookupPending || !artifactIdExists)
                                                    ? 'bg-slate-100 border-slate-200 text-slate-300 cursor-not-allowed'
                                                    : 'bg-slate-100 border-slate-300 hover:bg-slate-200 text-slate-600'
                                            ]" :title="artifactLookupPending ? 'Checking artifact...' : (artifactIdExists ? 'Browse Files' : 'Enter a valid existing artifact ID first')">
                                                <i class="fas fa-folder-open"></i>
                                            </button>
                                            
                                            <!-- Autocomplete Suggestions -->
                                            <div v-if="showSuggestions && suggestions.length > 0" class="absolute top-full left-0 w-full bg-white border border-gray-200 rounded-lg shadow-lg z-50 max-h-48 overflow-y-auto mt-1">
                                                <div 
                                                    v-for="(suggestion, index) in suggestions" 
                                                    :key="index"
                                                    @mousedown.prevent="selectSuggestion(suggestion)"
                                                    class="px-3 py-2 text-sm hover:bg-blue-50 cursor-pointer flex justify-between items-center"
                                                    :class="{'bg-blue-50': index === 0}"
                                                >
                                                    <span>[[ suggestion ]]</span>
                                                    <span v-if="index === 0" class="text-xs text-gray-400">Tab</span>
                                                </div>
                                            </div>
                                        </div>
                                        <p v-if="artifactInputError" class="text-xs text-red-600">[[ artifactInputError ]]</p>
                                    </div>
                                </div>

                                <div v-if="trainingParams.dataset_source === 'Upload'">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Upload Data</label>
                                    <div class="flex gap-2">
                                        <div v-if="trainingParams.uploaded_artifact" class="flex-grow bg-green-50 border border-green-200 rounded-lg px-3 py-2 text-sm text-green-800 flex items-center">
                                            <i class="fas fa-check-circle mr-2"></i> [[ trainingParams.uploaded_artifact ]]
                                        </div>
                                        <div v-else class="flex-grow bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-400 italic">
                                            No dataset uploaded yet
                                        </div>
                                        <button type="button" @click="showUploadModal = true" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition shadow-sm font-medium whitespace-nowrap">
                                            <i class="fas fa-cloud-upload-alt mr-1"></i> Upload Folder
                                        </button>
                                    </div>
                                </div>

                                <div v-if="trainingParams.dataset_source === 'BioImage Archive'">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Archive URL <span class="text-red-500">*</span></label>
                                    <div class="flex gap-2">
                                        <input v-model="trainingParams.bioimage_archive_url" required class="flex-grow bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition" placeholder="https://www.ebi.ac.uk/biostudies/bioimages/studies/...">
                                        <a href="https://www.ebi.ac.uk/biostudies/bioimages" target="_blank" rel="noopener noreferrer" class="px-4 py-2 bg-slate-100 border border-slate-300 rounded-lg hover:bg-slate-200 text-slate-700 transition text-sm whitespace-nowrap">
                                            <i class="fas fa-external-link-alt mr-1"></i> Search EBI
                                        </a>
                                    </div>
                                </div>
                                
                                <div class="md:col-span-2 space-y-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Base Model <span class="text-red-500">*</span></label>
                                    <div class="relative">
                                        <input v-model="trainingParams.model" required class="w-full bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition" placeholder="Pretrained ID or Session ID">
                                        <div class="absolute right-2 top-2 text-xs text-gray-400 space-x-1">
                                            <span class="cursor-pointer hover:text-blue-600" @click="trainingParams.model = 'cpsam'">cpsam</span>
                                            <span class="cursor-pointer hover:text-blue-600" @click="trainingParams.model = 'cyto3'">cyto3</span>
                                        </div>
                                    </div>
                                </div>

                                <div v-if="trainingParams.dataset_source !== 'BioImage Archive'" class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4 pt-2">
                                    <div class="md:col-span-2">
                                        <label class="block text-xs font-medium text-gray-500 uppercase tracking-wide mb-2">Train/Test Split</label>
                                        <div class="flex items-center gap-5 text-sm text-gray-700">
                                            <label class="inline-flex items-center gap-2 cursor-pointer">
                                                <input type="radio" value="manual" v-model="trainingParams.split_mode" class="text-blue-600 focus:ring-blue-500">
                                                <span>Manual test paths</span>
                                            </label>
                                            <label class="inline-flex items-center gap-2 cursor-pointer">
                                                <input type="radio" value="auto" v-model="trainingParams.split_mode" class="text-blue-600 focus:ring-blue-500">
                                                <span>Auto split</span>
                                            </label>
                                            <div v-if="trainingParams.split_mode === 'auto'" class="inline-flex items-center gap-2">
                                                <span class="text-xs text-gray-500">Train ratio</span>
                                                <input v-model.number="trainingParams.train_split_ratio" type="number" min="0.1" max="0.95" step="0.05" class="w-24 bg-white border border-gray-300 rounded-md px-2 py-1 text-sm">
                                            </div>
                                        </div>
                                        <p class="mt-1 text-xs text-gray-500" v-if="trainingParams.split_mode === 'auto'">Uses train paths only and splits into train/test (default 0.8).</p>
                                    </div>
                                     <div>
                                        <label class="block text-xs font-medium text-gray-500 uppercase tracking-wide mb-1">Train Images</label>
                                        <input v-model="trainingParams.train_images" class="w-full bg-white border border-gray-300 rounded-md px-3 py-2 text-sm" placeholder="e.g. images/*/*.tif">
                                        <div class="mt-1 text-xs text-gray-500 flex flex-wrap items-center gap-2">
                                            <span>Examples:</span>
                                            <button type="button" @click="applyTrainingGlobExample" class="text-blue-600 hover:underline">images/**/*.tif</button>
                                            <button type="button" @click="applyTrainingFolderExample" class="text-blue-600 hover:underline">images/ + annotations/</button>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="block text-xs font-medium text-gray-500 uppercase tracking-wide mb-1">Train Annotations</label>
                                        <input v-model="trainingParams.train_annotations" class="w-full bg-white border border-gray-300 rounded-md px-3 py-2 text-sm" placeholder="e.g. annotations/*/*_mask.ome.tif">
                                    </div>
                                    <div class="md:col-span-2">
                                        <label class="block text-xs font-medium text-gray-500 uppercase tracking-wide mb-1">Metadata Folder (Opt)</label>
                                        <input v-model="trainingParams.metadata_dir" class="w-full bg-white border border-gray-300 rounded-md px-3 py-2 text-sm" placeholder="e.g. metadata/">
                                        <p class="text-xs text-gray-500 mt-1">Use this to load image/annotation pairs from metadata JSON files; then explicit annotation masks are optional.</p>
                                    </div>
                                    <div v-if="trainingParams.split_mode === 'manual'">
                                        <label class="block text-xs font-medium text-gray-500 uppercase tracking-wide mb-1">Test Images (Opt)</label>
                                        <input v-model="trainingParams.test_images" class="w-full bg-white border border-gray-300 rounded-md px-3 py-2 text-sm" placeholder="Optional">
                                    </div>
                                    <div v-if="trainingParams.split_mode === 'manual'">
                                        <label class="block text-xs font-medium text-gray-500 uppercase tracking-wide mb-1">Test Annotations (Opt)</label>
                                        <input v-model="trainingParams.test_annotations" class="w-full bg-white border border-gray-300 rounded-md px-3 py-2 text-sm" placeholder="Optional">
                                    </div>
                                </div>
                                <div v-else class="md:col-span-2 rounded-lg border border-blue-200 bg-blue-50 px-4 py-3 text-sm text-blue-900">
                                    BioImage Archive mode discovers image/mask pairs from the archive URL automatically, so path and split fields are not needed.
                                </div>
                            </div>
                         </div>
                          </div>

                         <!-- Card: Hyperparameters -->
                         <div class="bg-white p-6 rounded-xl shadow-sm border border-gray-200">
                             <h3 class="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2"><i class="fas fa-sliders-h text-gray-400"></i> Hyperparameters</h3>
                             <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Epochs</label>
                                    <input v-model.number="trainingParams.n_epochs" type="number" min="1" required class="w-full bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Learning Rate</label>
                                    <input v-model.number="trainingParams.learning_rate" type="number" step="1e-7" required class="w-full bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Min Batch Masks</label>
                                    <input v-model.number="trainingParams.min_train_masks" type="number" min="1" class="w-full bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                            </div>
                         </div>

                         <div class="flex justify-end gap-4">
                             <button type="button" @click="currentTab = 'dashboard'" class="px-6 py-2.5 text-gray-600 font-medium hover:bg-gray-100 rounded-lg transition">Cancel</button>
                             <button type="submit" :disabled="isStartingTraining" class="bg-blue-600 text-white px-8 py-2.5 rounded-lg shadow-sm hover:bg-blue-700 hover:shadow-md transition-all font-medium disabled:opacity-50 flex items-center gap-2">
                                <i v-if="isStartingTraining" class="fas fa-circle-notch fa-spin"></i>
                                [[ isStartingTraining ? 'Starting...' : 'Start Training' ]]
                            </button>
                         </div>

                        <div v-if="trainingError" class="bg-red-50 text-red-800 p-4 rounded-lg text-sm border border-red-200 flex items-start gap-2">
                            <i class="fas fa-exclamation-circle mt-0.5"></i>
                            <span class="font-mono whitespace-pre-wrap">[[ trainingError ]]</span>
                        </div>

                     </form>
                </div>

                <!-- Session Details Tab (Dynamic) -->
                <div v-if="service && currentTab === 'session_details' && selectedSessionId" class="max-w-6xl mx-auto">
                    <div class="flex items-center gap-4 mb-6">
                        <button @click="currentTab = 'dashboard'" class="text-gray-400 hover:text-gray-600 transition">
                            <i class="fas fa-arrow-left text-xl"></i>
                        </button>
                        <div class="flex-1">
                             <h2 class="text-2xl font-bold text-gray-900 flex items-center gap-3">
                                 Session Analysis
                                 <span class="text-sm font-mono font-normal text-gray-500 bg-gray-100 px-2 py-0.5 rounded">[[ selectedSessionId ]]</span>
                             </h2>
                        </div>
                        <div class="flex items-center gap-2">
                            <button
                                v-if="currentSession?.status_type === 'running'"
                                @click="stopTraining(selectedSessionId)"
                                class="px-4 py-2 rounded-lg bg-red-600 text-white text-sm font-medium hover:bg-red-700 transition"
                            >
                                <i class="fas fa-stop mr-1"></i> Stop
                            </button>
                            <button
                                v-if="currentSession && ['stopped','unknown','failed'].includes(currentSession.status_type)"
                                @click="restartTraining(selectedSessionId)"
                                class="px-4 py-2 rounded-lg bg-blue-600 text-white text-sm font-medium hover:bg-blue-700 transition"
                            >
                                <i class="fas fa-rotate-right mr-1"></i> Restart
                            </button>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
                        <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                            <div class="text-sm text-gray-500 mb-1">Status</div>
                            <div class="text-lg font-bold capitalize" :class="statusTextColor(currentSession?.status_type)">[[ currentSession?.status_type ]]</div>
                        </div>
                        <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                            <div class="text-sm text-gray-500 mb-1">Progress</div>
                            <div class="text-lg font-bold text-gray-800">[[ currentSession?.current_epoch || 0 ]] <span class="text-sm text-gray-400 font-normal">/ [[ currentSession?.total_epochs ]] Epochs</span></div>
                        </div>
                        <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                            <div class="text-sm text-gray-500 mb-1">Samples</div>
                            <div class="text-lg font-bold text-gray-800">[[ currentSession?.n_train || '-' ]] <span class="text-sm text-gray-400 font-normal">Train</span></div>
                        </div>
                        <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                             <div class="text-sm text-gray-500 mb-1">Duration</div>
                            <div class="text-lg font-bold text-gray-800">[[ formatDuration(currentSession?.elapsed_seconds) ]]</div>
                        </div>
                    </div>

                    <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200 mb-8">
                        <h3 class="font-bold text-gray-700 mb-3 px-2">Training Hyperparameters</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3 text-sm">
                            <div class="bg-gray-50 rounded p-2"><span class="text-gray-500">Model</span><div class="font-mono text-gray-800">[[ currentSession?.model || '-' ]]</div></div>
                            <div class="bg-gray-50 rounded p-2"><span class="text-gray-500">Epochs</span><div class="font-mono text-gray-800">[[ currentSession?.n_epochs ?? currentSession?.total_epochs ?? '-' ]]</div></div>
                            <div class="bg-gray-50 rounded p-2"><span class="text-gray-500">Samples</span><div class="font-mono text-gray-800">[[ currentSession?.n_samples ?? 'all' ]]</div></div>
                            <div class="bg-gray-50 rounded p-2"><span class="text-gray-500">Learning Rate</span><div class="font-mono text-gray-800">[[ currentSession?.learning_rate ?? '-' ]]</div></div>
                            <div class="bg-gray-50 rounded p-2"><span class="text-gray-500">Weight Decay</span><div class="font-mono text-gray-800">[[ currentSession?.weight_decay ?? '-' ]]</div></div>
                            <div class="bg-gray-50 rounded p-2"><span class="text-gray-500">Min Train Masks</span><div class="font-mono text-gray-800">[[ currentSession?.min_train_masks ?? '-' ]]</div></div>
                            <div class="bg-gray-50 rounded p-2"><span class="text-gray-500">Validation Interval</span><div class="font-mono text-gray-800">[[ currentSession?.validation_interval ?? 'default (10)' ]]</div></div>
                        </div>
                    </div>
                
                    <!-- Charts -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-4 px-2">Loss History</h3>
                            <div id="lossChart" class="w-full h-72"></div>
                        </div>
                        <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-4 px-2">Validation Metrics</h3>
                            <div v-if="hasMetrics" id="metricsChart" class="w-full h-72"></div>
                             <div v-else class="h-72 flex items-center justify-center text-gray-400 italic text-center px-6">
                                <span v-if="hasValidationSet">Validation is enabled, metrics will appear after the first evaluated epoch.</span>
                                <span v-else>Validation metrics require both test images and test annotations.</span>
                            </div>
                        </div>
                    </div>

                    <!-- Logs & Actions -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="bg-slate-900 rounded-xl overflow-hidden text-slate-300 font-mono text-xs flex flex-col h-64 shadow-sm border border-slate-800">
                            <div class="bg-slate-950 px-4 py-2 border-b border-slate-800 font-bold text-slate-500 flex justify-between">
                                <span>SYSTEM LOG</span>
                                <span class="text-[10px]">[[ currentSession?.status_type === 'running' ? 'LIVE' : 'OFFLINE' ]]</span>
                            </div>
                            <div class="p-4 overflow-y-auto log-area flex-grow">
                                <p class="mb-2"><span class="text-slate-500">Session ID:</span> [[ selectedSessionId ]]</p>
                                <p class="mb-2 text-yellow-500">> [[ currentSession?.message ]]</p>
                                <p v-if="currentSession?.status_type === 'failed'" class="text-red-400 mt-2">Error: Process terminated unexpectedly.</p>
                            </div>
                        </div>

                         <div v-if="currentSession?.status_type === 'completed'" class="bg-green-50 rounded-xl p-6 border border-green-200 flex flex-col justify-center">
                             <h3 class="font-bold text-green-900 mb-2">Ready for Export</h3>
                             <p class="text-green-700 text-sm mb-4">Package this model as a standardized BioImage.io artifact.</p>
                             
                             <div class="space-y-3">
                                 <div>
                                     <label class="block text-xs font-bold text-green-800 uppercase tracking-wide mb-1">Model Name</label>
                                     <input v-model="exportModelName" placeholder="my-model-v1" class="w-full border-green-300 rounded px-3 py-2 text-sm focus:ring-green-500 focus:border-green-500">
                                 </div>
                                 <button @click="exportModel" :disabled="isExporting" class="w-full bg-green-600 text-white px-4 py-3 rounded-lg hover:bg-green-700 disabled:opacity-50 font-medium shadow-sm transition">
                                     <i v-if="isExporting" class="fas fa-spinner fa-spin mr-1"></i>
                                     [[ isExporting ? 'Exporting Package...' : 'Export to Artifact Manager' ]]
                                 </button>
                             </div>
                             
                             <div v-if="exportResult" class="mt-4 p-3 bg-white rounded border border-green-200 text-sm">
                                 <div class="flex items-center text-green-600 font-bold mb-1"><i class="fas fa-check-circle mr-2"></i> Export Success</div>
                                 <a :href="exportResult.artifact_url" target="_blank" class="text-blue-600 hover:underline break-all block">[[ exportResult.model_name ]]</a>
                             </div>
                        </div>
                    </div>
                </div>

                 <!-- Inference Tab -->
                 <div v-if="currentTab === 'inference'" class="max-w-7xl mx-auto lg:h-[calc(100vh-8rem)] h-auto flex flex-col">
                     <h2 class="text-2xl font-bold text-gray-900 mb-6 flex-none">Live Inference</h2>

                     <div v-if="service" class="flex-grow grid grid-cols-1 lg:grid-cols-12 gap-6 lg:min-h-0 h-auto">
                         <!-- Left: Controls -->
                         <div class="lg:col-span-4 bg-white rounded-xl shadow-sm border border-gray-200 flex flex-col overflow-hidden">
                            <div class="p-4 border-b border-gray-100 flex-none bg-gray-50/50">
                                <h3 class="font-bold text-gray-700">Configuration</h3>
                            </div>
                            
                            <div class="p-6 overflow-y-auto flex-grow space-y-5">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Model Source</label>
                                    <select v-model="inferenceParams.model" class="w-full bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm">
                                         <optgroup label="Pretrained Models">
                                             <option v-for="m in pretrainedModels" :key="m" :value="m">[[ m ]]</option>
                                         </optgroup>
                                         <optgroup label="Your Sessions">
                                             <option v-for="(s, id) in sessions" :key="id" :value="id" v-show="s.status_type==='completed' || s.status_type==='running'">
                                                 [[ s.status_type==='running' ? 'ðŸŸ¢' : 'âš«' ]] [[ id.slice(0,8) ]]
                                             </option>
                                         </optgroup>
                                    </select>
                                    <p class="text-xs text-gray-500 mt-1" v-if="sessions[inferenceParams.model]?.status_type === 'running'">
                                        <i class="fas fa-bolt text-yellow-500"></i> Using live checkpoint from running session.
                                    </p>
                                </div>

                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Average Diameter (px)</label>
                                    <input v-model.number="inferenceParams.diameter" type="number" placeholder="0 = Auto" class="w-full bg-gray-50 border border-gray-300 rounded-lg px-3 py-2 text-sm">
                                </div>

                                <div v-if="runningTrainingSessionsCount > 0" class="bg-amber-50 border border-amber-200 text-amber-800 rounded-lg p-3 text-xs leading-relaxed">
                                    <i class="fas fa-triangle-exclamation mr-1"></i>
                                    [[ runningTrainingSessionsCount ]] training session(s) are running. Inference may fail with GPU memory errors while training is active.
                                </div>

                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Input Image</label>
                                    <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:bg-gray-50 transition cursor-pointer relative group">
                                        <input type="file" @change="handleInferenceFile" accept="image/*,.tif,.tiff" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                                        <div v-if="!inferenceFile">
                                            <i class="fas fa-image text-gray-400 text-2xl mb-2 group-hover:scale-110 transition-transform"></i>
                                            <p class="text-xs text-gray-500">Click or Drag Image Here</p>
                                        </div>
                                        <div v-else class="text-sm font-medium text-blue-600 truncate px-2">
                                            [[ inferenceFile.name ]]
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="p-4 border-t border-gray-100 bg-gray-50/50 flex-none">
                                <button @click="runInference" :disabled="!inferenceFile || isInferring" class="w-full bg-purple-600 text-white px-4 py-3 rounded-lg hover:bg-purple-700 transition disabled:opacity-50 font-medium shadow-sm flex justify-center items-center gap-2">
                                    <i v-if="isInferring" class="fas fa-spinner fa-spin"></i>
                                    [[ isInferring ? 'Processing...' : 'Run Segmentation' ]]
                                </button>
                            </div>
                         </div>

                         <!-- Right: Visualization -->
                         <div class="lg:col-span-8 bg-gray-900 rounded-xl overflow-hidden shadow-lg border border-gray-800 relative flex items-center justify-center min-h-[400px]">
                             <div v-if="!inferencePreview" class="text-gray-600 text-center">
                                 <i class="fas fa-image text-4xl mb-3 opacity-50"></i>
                                 <p>No image loaded</p>
                             </div>
                             
                             <div v-else class="relative w-full h-full p-4 flex items-center justify-center bg-[url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAHElEQVQYV2NkYGAwYcACGRkY/sfHx2BEV4yhEAB5ZwX9qj2t2QAAAABJRU5ErkJggg==')]">
                                <img ref="previewImg" :src="inferencePreview" class="max-w-full max-h-full object-contain shadow-2xl" @load="onImageLoad">
                                <canvas ref="inferenceCanvas" class="absolute pointer-events-none max-w-full max-h-full aspect-auto" :style="canvasStyle"></canvas>
                             </div>

                             <!-- Legend -->
                             <transition name="fade">
                                 <div v-if="inferenceResult" class="absolute bottom-4 right-4 bg-black/80 backdrop-blur text-white text-xs px-3 py-1.5 rounded-full border border-white/10 shadow-lg">
                                     <i class="fas fa-cubes text-purple-400 mr-1"></i> Found <b>[[ inferenceObjectCount ]]</b> objects
                                 </div>
                             </transition>
                         </div>
                     </div>
                     <div v-else class="bg-white rounded-xl border border-gray-200 shadow-sm p-8 text-center">
                        <div class="inline-flex items-center justify-center w-14 h-14 rounded-full bg-purple-50 text-purple-600 mb-4">
                            <i class="fas fa-circle-notch fa-spin text-xl"></i>
                        </div>
                        <h3 class="text-lg font-semibold text-gray-900 mb-2">Initializing inference service</h3>
                        <p class="text-sm text-gray-600 mb-5">
                            The worker connection is active, but the inference backend is not ready yet.
                        </p>
                        <button @click="connect" class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-purple-600 text-white text-sm font-medium hover:bg-purple-700 transition">
                            <i class="fas fa-rotate-right"></i>
                            Retry Connection
                        </button>
                    </div>
                </div>

            </div>
        </main>


        <!-- File Browser Modal -->
        <div v-if="showFileBrowser" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 fade-enter-active">
            <div class="bg-white rounded-2xl p-6 w-full max-w-2xl shadow-2xl flex flex-col max-h-[80vh]">
                <div class="flex justify-between items-center mb-4 border-b border-gray-100 pb-4 flex-none">
                    <div>
                        <h3 class="text-lg font-bold text-gray-900">Artifact Explorer</h3>
                        <p class="text-xs text-gray-500">[[ getSelectedArtifactId() || 'No artifact selected' ]]</p>
                    </div>
                    <button @click="showFileBrowser = false" class="text-gray-400 hover:text-gray-600"><i class="fas fa-times"></i></button>
                </div>

                <div class="flex-none bg-gray-50 p-2 rounded-lg mb-4 flex items-center gap-2 text-sm text-gray-600 border border-gray-200">
                    <button @click="browserNavigateUp" class="hover:bg-gray-200 p-1 rounded transition" :disabled="!browserPath"><i class="fas fa-arrow-up"></i></button>
                    <span class="font-mono text-gray-400">/</span>
                    <span class="font-mono">[[ browserPath ]]</span>
                </div>

                <div class="flex-grow overflow-y-auto min-h-0 bg-white border border-gray-100 rounded-lg">
                    <div v-if="browserLoading" class="p-8 text-center text-gray-400">
                        <i class="fas fa-circle-notch fa-spin text-2xl mb-2"></i><br>Loading files...
                    </div>
                    <div v-else-if="browserError" class="p-8 text-center text-red-400">
                        <i class="fas fa-exclamation-circle text-2xl mb-2"></i><br>[[ browserError ]]
                    </div>
                    <ul v-else class="divide-y divide-gray-50">
                        <li v-if="browserPath" @click="browserNavigateUp" class="px-4 py-2 hover:bg-gray-50 cursor-pointer flex items-center gap-3 text-gray-500">
                            <i class="fas fa-level-up-alt"></i> ..
                        </li>
                        <li v-for="item in browserVisibleItems" :key="item.fullPath" 
                            @click="handleItemClick(item)"
                            class="px-4 py-2 hover:bg-blue-50 group flex items-center justify-between transition-colors cursor-pointer">
                            
                            <div class="flex items-center gap-3 overflow-hidden">
                                <i :class="item.type === 'folder' ? 'fas fa-folder text-yellow-400' : 'fas fa-file text-gray-400'"></i>
                                <span class="text-sm truncate" :class="item.type === 'folder' ? 'font-medium text-gray-700' : 'text-gray-500'">[[ item.name ]]</span>
                            </div>

                            <div v-if="item.type === 'folder'" class="flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                 <button @click.stop="selectFolderFor(item.fullPath, 'images')" class="text-[10px] px-2 py-1 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 font-medium whitespace-nowrap">Use as Images</button>
                                 <button @click.stop="selectFolderFor(item.fullPath, 'annotations')" class="text-[10px] px-2 py-1 bg-purple-100 text-purple-700 rounded hover:bg-purple-200 font-medium whitespace-nowrap">Use as Annotations</button>
                            </div>
                        </li>
                    </ul>
                     <div v-if="!browserLoading && browserVisibleItems.length === 0" class="p-8 text-center text-gray-400 text-sm">
                         Empty folder
                    </div>
                </div>

                <div class="mt-4 pt-4 border-t border-gray-100 flex justify-between items-center text-xs text-gray-400">
                    <div class="flex items-center gap-3">
                        <span>Current: /[[ browserPath ]]</span>
                        <transition name="fade">
                            <span v-if="browserFeedback" class="text-green-600 font-bold bg-green-50 px-2 py-0.5 rounded border border-green-200">
                                <i class="fas fa-check"></i> [[ browserFeedback ]]
                            </span>
                        </transition>
                    </div>
                    <div class="flex gap-2">
                         <button @click="selectFolderFor(browserPath, 'images')" class="px-3 py-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded transition">Set Current as Images</button>
                         <button @click="selectFolderFor(browserPath, 'annotations')" class="px-3 py-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded transition">Set Current as Annotations</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Upload Modal -->
        <div v-if="showUploadModal" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 fade-enter-active">
            <div class="bg-white rounded-2xl p-8 w-full max-w-lg shadow-2xl transform transition-all">
                <h3 class="text-xl font-bold mb-1 text-gray-900">Upload Dataset</h3>
                <p class="text-sm text-gray-500 mb-6">Create a new dataset artifact from a local folder.</p>
                
                <form @submit.prevent="uploadDataset" class="space-y-5">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Dataset Alias</label>
                        <input v-model="uploadParams.alias" required class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-green-500 outline-none" placeholder="e.g. skin-tissue-v1">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Select Folder</label>
                        <input type="file" ref="folderInput" @change="handleFolderSelect" webkitdirectory directory multiple required class="w-full text-sm border border-gray-300 rounded-lg p-2 bg-gray-50">
                        <p class="text-xs text-gray-500 mt-1.5"><i class="fas fa-info-circle"></i> Folder should contain images and mask files.</p>
                    </div>
                    
                    <div v-if="isUploading" class="space-y-2 pt-2">
                         <div class="flex justify-between text-xs font-medium text-gray-600">
                            <span>Uploading...</span>
                            <span>[[ uploadProgress ]]%</span>
                        </div>
                        <div class="w-full bg-gray-100 rounded-full h-2 overflow-hidden">
                            <div class="bg-green-500 h-2 rounded-full transition-all duration-300" :style="{ width: uploadProgress + '%' }"></div>
                        </div>
                        <div class="text-xs text-gray-400 truncate">[[ uploadStatus ]]</div>
                    </div>

                    <div class="flex justify-end gap-3 pt-4 border-t border-gray-100">
                        <button type="button" @click="showUploadModal = false" class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg font-medium transition">Cancel</button>
                        <button type="submit" :disabled="isUploading" class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 font-medium shadow-sm transition">Upload</button>
                    </div>
                </form>
            </div>
        </div>

    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, watch, nextTick } = Vue;

        const app = createApp({
            setup() {
                // Connection State
                const serverUrl = ref('https://hypha.aicell.io');
                const monitoringSessionId = ref(null);
                const workspace = ref('');
                const authToken = ref('');
                const isConnected = ref(false);
                const isConnecting = ref(false);
                const autoConnectError = ref('');
                const showTokenInput = ref(false);

                // Service Discovery
                const availableServices = ref([]);
                const selectedServiceId = ref('');
                const service = ref(null);
                const isScanning = ref(false);

                // Navigation
                const currentTab = ref('dashboard');
                const tabs = [
                    { id: 'dashboard', name: 'Dashboard', icon: 'fas fa-chart-line' },
                    { id: 'training', name: 'New Training', icon: 'fas fa-plus-circle' },
                    { id: 'inference', name: 'Inference', icon: 'fas fa-microscope' },
                ];

                // Training Data
                const syncError = ref(null);
                const sessions = ref({});
                const selectedSessionId = ref(null);
                const refreshLoading = ref(false);
                
                // Form Data
                const trainingParams = reactive({
                    dataset_source: 'Artifact',
                    artifact_input: '',
                    uploaded_artifact: '',
                    bioimage_archive_url: '',
                    model: 'cpsam',
                    train_images: 'images/',
                    train_annotations: 'annotations/',
                    metadata_dir: '',
                    split_mode: 'manual',
                    train_split_ratio: 0.8,
                    test_images: '',
                    test_annotations: '',
                    n_epochs: 50,
                    learning_rate: 1e-5,
                    min_train_masks: 5,
                });
                const isStartingTraining = ref(false);
                const trainingError = ref('');

                // Upload Data
                const showUploadModal = ref(false);
                const uploadParams = reactive({ alias: '' });
                const isUploading = ref(false);
                const uploadProgress = ref(0);
                const uploadStatus = ref('');
                const folderInput = ref(null);

                // Inference Data
                const inferenceParams = reactive({ model: 'cpsam', diameter: null });
                const pretrainedModels = ['cpsam', 'cyto3', 'nuclei', 'tissuenet'];
                const inferenceFile = ref(null);
                const inferencePreview = ref(null);
                const isInferring = ref(false);
                const inferenceResult = ref(null);
                const inferenceCanvas = ref(null);
                const previewImg = ref(null);
                const canvasStyle = reactive({ top: '0', left: '0', width: '100%', height: '100%' });
                const inferenceObjectCount = ref(0);

                // Export
                const exportModelName = ref('');
                const isExporting = ref(false);
                const exportResult = ref(null);

                // File Browser
                const showFileBrowser = ref(false);
                const browserFiles = ref([]);
                const browserPathTypes = reactive({});
                const browserPath = ref(''); 
                const browserLoading = ref(false);
                const browserError = ref('');


                // Autocomplete Logic
                const suggestions = ref([]);
                const showSuggestions = ref(false);
                const artifactInputError = ref('');
                const artifactIdExists = ref(false);
                const artifactLookupPending = ref(false);
                const artifactLookupVersion = ref(0);

                const workspaceSuggestionCache = ref([]);
                const artifactInputVersion = ref(0);
                const workspaceClients = reactive({});
                const artifactDebug = reactive({
                    cacheSize: 0,
                    lastShape: '',
                    lastWorkspace: '',
                    lastQuery: '',
                    globalMatches: 0,
                    scopedMatches: 0,
                    sessionMatches: 0,
                    suggestions: 0,
                    lastError: '',
                });

                const normalizeWorkspaceId = (entry) => {
                    if (!entry) return null;
                    if (typeof entry === 'string') return entry;
                    return entry.id || entry.workspace || entry.name || null;
                };

                const isWorkspacePermissionError = (error) => {
                    const message = String(error?.message || error || '').toLowerCase();
                    return (
                        message.includes('permission denied') ||
                        message.includes('access denied') ||
                        message.includes('not authorized') ||
                        message.includes('unauthorized')
                    );
                };

                const fetchWorkspaces = async () => {
                    const workspaces = new Set();
                    if (workspace.value) workspaces.add(workspace.value);
                    const userWs = getUserWorkspace();
                    if (userWs) workspaces.add(userWs);
                    workspaces.add('bioimage-io');

                    if (!window.hyphaClient) return Array.from(workspaces);

                    if (workspaceSuggestionCache.value.length > 0) {
                        workspaceSuggestionCache.value.forEach((ws) => workspaces.add(ws));
                        return Array.from(workspaces);
                    }

                    try {
                        const listed = await window.hyphaClient.listWorkspaces();
                        const normalized = (Array.isArray(listed) ? listed : [])
                            .map(normalizeWorkspaceId)
                            .filter(Boolean);
                        workspaceSuggestionCache.value = normalized;
                        normalized.forEach((ws) => workspaces.add(ws));
                    } catch (e) {
                        console.warn('Failed to fetch workspaces via server.listWorkspaces():', e);
                    }

                    return Array.from(workspaces);
                };

                const getWorkspaceClient = async (targetWorkspace) => {
                    if (!targetWorkspace) {
                        throw new Error('Workspace is required for artifact lookup.');
                    }

                    const activeWorkspace = workspace.value || window.hyphaClient?.config?.workspace || '';
                    if (activeWorkspace && targetWorkspace === activeWorkspace && window.hyphaClient) {
                        return window.hyphaClient;
                    }

                    if (workspaceClients[targetWorkspace]) return workspaceClients[targetWorkspace];

                    const config = {
                        server_url: serverUrl.value,
                        workspace: targetWorkspace,
                        method_timeout: 120000,
                    };
                    const tokenForLookup = authToken.value || window.hyphaClient?.config?.token || null;
                    if (tokenForLookup) {
                        config.token = tokenForLookup;
                    } else {
                        throw new Error('Missing auth token for cross-workspace artifact lookup.');
                    }

                    const client = await hyphaWebsocketClient.connectToServer(config);
                    workspaceClients[targetWorkspace] = client;
                    return client;
                };

                const normalizeArtifactListResponse = (listed) => {
                    if (Array.isArray(listed)) {
                        artifactDebug.lastShape = 'array';
                        return listed;
                    }
                    if (listed?.items && Array.isArray(listed.items)) {
                        artifactDebug.lastShape = 'items-array';
                        return listed.items;
                    }
                    if (listed?.artifacts && Array.isArray(listed.artifacts)) {
                        artifactDebug.lastShape = 'artifacts-array';
                        return listed.artifacts;
                    }
                    if (listed && typeof listed === 'object') {
                        artifactDebug.lastShape = 'object-map';
                        if (listed.items && typeof listed.items === 'object') return Object.values(listed.items);
                        if (listed.artifacts && typeof listed.artifacts === 'object') return Object.values(listed.artifacts);
                        return Object.values(listed);
                    }
                    artifactDebug.lastShape = typeof listed;
                    return [];
                };

                const queryWorkspaceArtifacts = async (workspaceId, queryText) => {
                    const query = String(queryText || '').trim();
                    const keywords = query ? [query] : [];
                    let am = null;
                    let lastAttemptError = null;
                    try {
                        const client = await getWorkspaceClient(workspaceId);
                        am = await client.getService('public/artifact-manager');
                    } catch (error) {
                        artifactDebug.lastError = String(error?.message || error);
                        if (isWorkspacePermissionError(error)) {
                            artifactInputError.value = `Permission denied to workspace '${workspaceId}'.`;
                        }
                        return [];
                    }
                    
                    const attempts = [
                        () => am.list({ keywords, limit: 30, _rkwargs: true }),
                        () => am.list({ keywords, limit: 30 }),
                        () => am.list(workspaceId, { keywords, limit: 30 }),
                        () => am.list(workspaceId, { keywords }),
                    ];

                    for (const attempt of attempts) {
                        try {
                            const listed = await attempt();
                            const rawItems = normalizeArtifactListResponse(listed);
                            const normalized = rawItems
                                .map((item) => {
                                    const entry = normalizeArtifactEntry(item);
                                    if (!entry) return null;
                                    if (entry.workspace) return entry;
                                    return {
                                        workspace: workspaceId,
                                        alias: entry.alias,
                                        fullId: `${workspaceId}/${entry.alias}`,
                                    };
                                })
                                .filter(Boolean);

                            artifactDebug.cacheSize = normalized.length;
                            artifactDebug.lastError = '';
                            return normalized;
                        } catch (error) {
                            lastAttemptError = error;
                            artifactDebug.lastError = String(error?.message || error);
                            if (isWorkspacePermissionError(error)) {
                                artifactInputError.value = `Permission denied to workspace '${workspaceId}'.`;
                            }
                        }
                    }

                    if (lastAttemptError && !artifactInputError.value) {
                        const message = String(lastAttemptError?.message || lastAttemptError || '').trim();
                        artifactInputError.value = `Unable to access workspace '${workspaceId}'. ${message}`.trim();
                    }

                    return [];
                };

                const checkArtifactExists = async (workspaceId, alias) => {
                    const lookupVersion = ++artifactLookupVersion.value;
                    const normalizedWorkspace = String(workspaceId || '').trim();
                    const normalizedAlias = String(alias || '').trim();

                    if (!normalizedWorkspace || !normalizedAlias) {
                        artifactIdExists.value = false;
                        artifactLookupPending.value = false;
                        return false;
                    }

                    const artifactId = `${normalizedWorkspace}/${normalizedAlias}`;
                    artifactLookupPending.value = true;

                    try {
                        const client = await getWorkspaceClient(normalizedWorkspace);
                        const am = await client.getService('public/artifact-manager');
                        const attempts = [
                            () => am.get(artifactId, { _rkwargs: true }),
                            () => am.get(artifactId),
                            () => (typeof am.read === 'function' ? am.read(artifactId) : Promise.reject(new Error('read unavailable'))),
                        ];

                        for (const attempt of attempts) {
                            try {
                                const result = await attempt();
                                if (lookupVersion !== artifactLookupVersion.value) return false;
                                const exists = !!result;
                                artifactIdExists.value = exists;
                                return exists;
                            } catch (error) {
                                if (isWorkspacePermissionError(error)) {
                                    artifactInputError.value = `Permission denied to workspace '${normalizedWorkspace}'.`;
                                }
                            }
                        }
                    } catch (_e) {
                        // Keep exists=false; detailed errors are handled in autocomplete path.
                    } finally {
                        if (lookupVersion === artifactLookupVersion.value) {
                            artifactLookupPending.value = false;
                        }
                    }

                    if (lookupVersion === artifactLookupVersion.value) {
                        artifactIdExists.value = false;
                    }
                    return false;
                };

                const normalizeArtifactEntry = (item) => {
                    if (!item) return null;
                    if (typeof item === 'string') {
                        if (!item.includes('/')) {
                            return {
                                workspace: null,
                                alias: item,
                                fullId: item,
                            };
                        }
                        const firstSlash = item.indexOf('/');
                        return {
                            workspace: item.slice(0, firstSlash),
                            alias: item.slice(firstSlash + 1),
                            fullId: item,
                        };
                    }

                    const workspaceId = item.workspace || item?.manifest?.workspace || item.parent_id || null;
                    const alias = item.alias || item.name || item?.manifest?.alias || null;
                    const itemId = item.id || item.path || item.key || null;

                    if (workspaceId && alias) {
                        const cleanWorkspace = String(workspaceId).split('/')[0];
                        return {
                            workspace: cleanWorkspace,
                            alias,
                            fullId: `${cleanWorkspace}/${alias}`,
                        };
                    }

                    if (typeof itemId === 'string' && itemId.includes('/')) {
                        const firstSlash = itemId.indexOf('/');
                        return {
                            workspace: itemId.slice(0, firstSlash),
                            alias: itemId.slice(firstSlash + 1),
                            fullId: itemId,
                        };
                    }

                    if (alias) {
                        return {
                            workspace: null,
                            alias,
                            fullId: alias,
                        };
                    }

                    return null;
                };

                const collectSessionArtifactIds = () => {
                    const artifactIds = new Set();
                    for (const session of Object.values(sessions.value || {})) {
                        if (!session || typeof session !== 'object') continue;

                        const candidates = [
                            session.artifact,
                            session.dataset,
                            session.dataset_id,
                            session?.params?.artifact,
                            session?.training_params?.artifact,
                            session?.config?.artifact,
                        ];

                        for (const candidate of candidates) {
                            if (typeof candidate === 'string' && candidate.includes('/')) {
                                artifactIds.add(candidate);
                            }
                        }
                    }
                    return Array.from(artifactIds);
                };

                const handleArtifactInput = async () => {
                     const requestVersion = ++artifactInputVersion.value;
                     const val = String(trainingParams.artifact_input || '').trim();
                     artifactDebug.lastQuery = val;
                     artifactInputError.value = '';

                     if (!val) {
                         suggestions.value = [];
                         showSuggestions.value = false;
                         artifactDebug.suggestions = 0;
                         artifactIdExists.value = false;
                         artifactLookupPending.value = false;
                         return;
                     }

                     if (!val.includes('/')) {
                         artifactIdExists.value = false;
                         artifactLookupPending.value = false;
                         const workspaces = await fetchWorkspaces();
                         if (requestVersion !== artifactInputVersion.value) return;
                         suggestions.value = workspaces
                            .filter((w) => w.toLowerCase().startsWith(val.toLowerCase()))
                            .slice(0, 20);
                         showSuggestions.value = suggestions.value.length > 0;
                                 artifactDebug.suggestions = suggestions.value.length;
                                 console.info('[ArtifactAutocomplete] workspace suggestions', {
                                     query: val,
                                     count: suggestions.value.length,
                                 });
                         return;
                     }

                     const parts = val.split('/');
                     if (parts.length === 2) {
                         const ws = parts[0];
                         const query = parts[1].toLowerCase();
                         checkArtifactExists(ws, parts[1]);
                         artifactDebug.lastWorkspace = ws;
                         const remoteMatches = await queryWorkspaceArtifacts(ws, query);
                         if (requestVersion !== artifactInputVersion.value) return;

                         const scopedMatches = remoteMatches
                            .filter((entry) => entry.alias.toLowerCase().startsWith(query))
                            .map((entry) => entry.fullId);

                        const sessionMatches = collectSessionArtifactIds()
                            .filter((artifactId) => artifactId.startsWith(`${ws}/`))
                            .filter((artifactId) => artifactId.slice(ws.length + 1).toLowerCase().startsWith(query));

                        artifactDebug.globalMatches = 0;
                        artifactDebug.scopedMatches = scopedMatches.length;
                        artifactDebug.sessionMatches = sessionMatches.length;
                        suggestions.value = Array.from(new Set([...scopedMatches, ...sessionMatches])).slice(0, 30);
                        showSuggestions.value = suggestions.value.length > 0;
                        artifactDebug.suggestions = suggestions.value.length;
                        console.info('[ArtifactAutocomplete] artifact suggestions', {
                            workspace: ws,
                            query,
                            globalMatches: 0,
                            scopedMatches: scopedMatches.length,
                            sessionMatches: sessionMatches.length,
                            finalSuggestions: suggestions.value.length,
                            sample: suggestions.value.slice(0, 5),
                        });
                     } else {
                                artifactIdExists.value = false;
                                artifactLookupPending.value = false;
                        suggestions.value = [];
                        showSuggestions.value = false;
                        artifactDebug.suggestions = 0;
                     }
                };

                const selectSuggestion = (s) => {
                     // If it's a workspace (no slash), add slash
                     if (!s.includes('/')) {
                         trainingParams.artifact_input = s + '/';
                         // Refocus input to keep typing?
                         // Ensure handleArtifactInput runs for the new value
                         handleArtifactInput();
                     } else {
                         trainingParams.artifact_input = s;
                         showSuggestions.value = false;
                     }
                };
                
                const acceptSuggestion = () => {
                     if (showSuggestions.value && suggestions.value.length > 0) {
                         selectSuggestion(suggestions.value[0]);
                     }
                };
                
                const closeSuggestions = () => {
                    // Timeout to allow click event to propagate
                     setTimeout(() => showSuggestions.value = false, 200);
                };

                // Computed Properties
                const currentSession = computed(() => selectedSessionId.value ? sessions.value[selectedSessionId.value] : null);
                const monitoredSession = computed(() => monitoringSessionId.value ? sessions.value[monitoringSessionId.value] : null);
                const hasMetrics = computed(() => currentSession.value?.test_metrics?.length > 0);
                const hasValidationSet = computed(() => (currentSession.value?.n_test || 0) > 0);
                const runningTrainingSessionsCount = computed(() =>
                    Object.values(sessions.value).filter((s) => s && s.status_type === 'running').length
                );

                const to2DMaskArray = (maskValue) => {
                    if (!maskValue) return null;
                    if (Array.isArray(maskValue) && Array.isArray(maskValue[0])) return maskValue;
                    if (Array.isArray(maskValue) && maskValue.length > 0 && typeof maskValue[0] === 'number') return null;
                    if (typeof maskValue === 'object' && maskValue.encoding === 'ndarray_base64' && maskValue.shape && maskValue.data) {
                        const shape = maskValue.shape;
                        if (!Array.isArray(shape) || shape.length < 2) return null;
                        const h = shape[shape.length - 2];
                        const w = shape[shape.length - 1];
                        if (!Number.isInteger(h) || !Number.isInteger(w) || h <= 0 || w <= 0) return null;

                        const b64 = maskValue.data;
                        const bin = atob(b64);
                        const bytes = new Uint8Array(bin.length);
                        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);

                        let typed = null;
                        const dtype = String(maskValue.dtype || '').toLowerCase();
                        if (dtype.includes('uint16')) typed = new Uint16Array(bytes.buffer, bytes.byteOffset, Math.floor(bytes.byteLength / 2));
                        else if (dtype.includes('uint32')) typed = new Uint32Array(bytes.buffer, bytes.byteOffset, Math.floor(bytes.byteLength / 4));
                        else if (dtype.includes('int16')) typed = new Int16Array(bytes.buffer, bytes.byteOffset, Math.floor(bytes.byteLength / 2));
                        else if (dtype.includes('int32')) typed = new Int32Array(bytes.buffer, bytes.byteOffset, Math.floor(bytes.byteLength / 4));
                        else typed = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);

                        if (!typed || typed.length < h * w) return null;
                        const out = [];
                        for (let y = 0; y < h; y++) {
                            const rowStart = y * w;
                            const row = new Array(w);
                            for (let x = 0; x < w; x++) row[x] = typed[rowStart + x];
                            out.push(row);
                        }
                        return out;
                    }
                    if (typeof maskValue === 'object' && maskValue.shape && maskValue.data) {
                        const shape = maskValue.shape;
                        const data = maskValue.data;
                        if (Array.isArray(shape) && shape.length >= 2 && Array.isArray(data)) {
                            const h = shape[shape.length - 2];
                            const w = shape[shape.length - 1];
                            if (Number.isInteger(h) && Number.isInteger(w) && h > 0 && w > 0 && data.length >= h * w) {
                                const out = [];
                                for (let y = 0; y < h; y++) {
                                    const rowStart = y * w;
                                    out.push(data.slice(rowStart, rowStart + w));
                                }
                                return out;
                            }
                        }
                    }
                    return null;
                };

                const isGpuOomError = (message) => {
                    const text = String(message || '').toLowerCase();
                    return text.includes('cuda out of memory') || text.includes('outofmemoryerror');
                };

                const formatServiceError = (error, context) => {
                    const base = String(error?.message || error || 'Unknown error');
                    if (isGpuOomError(base)) {
                        return `${context} failed due to GPU memory pressure. Stop active training sessions, wait a few seconds, then retry.`;
                    }
                    return base;
                };

                const applyTrainingGlobExample = () => {
                    trainingParams.train_images = 'images/*/*.tif';
                    trainingParams.train_annotations = 'annotations/*/*_mask.ome.tif';
                };

                const getSelectedArtifactId = () => {
                    if (trainingParams.dataset_source === 'Upload') {
                        return trainingParams.uploaded_artifact;
                    }
                    return trainingParams.artifact_input;
                };

                const applyTrainingFolderExample = () => {
                    trainingParams.train_images = 'images/';
                    trainingParams.train_annotations = 'annotations/';
                };

                const getUserWorkspace = () => {
                    const explicitWs = workspace.value;
                    if (explicitWs) return explicitWs;

                    const userId = window.hyphaClient?.config?.user?.id;
                    if (userId) return `ws-user-${userId}`;

                    return null;
                };

                const getServiceWorkspace = () => {
                    const serviceId = selectedServiceId.value || service.value?.id;
                    if (!serviceId || typeof serviceId !== 'string') return null;
                    const firstSlash = serviceId.indexOf('/');
                    if (firstSlash <= 0) return null;
                    return serviceId.slice(0, firstSlash);
                };

                // --- Lifecycle Hooks ---
                onMounted(async () => {
                    // Parse URL parameters for auto-connect
                    const params = new URLSearchParams(window.location.search);
                    if (params.has('server_url')) serverUrl.value = params.get('server_url');
                    
                    // Check URL token first, then localStorage
                    if (params.has('token')) {
                        authToken.value = params.get('token');
                    } else {
                        const savedToken = localStorage.getItem('hypha_token');
                        if (savedToken) {
                            try {
                                const parsedToken = JSON.parse(savedToken);
                                authToken.value = parsedToken?.tokenString || parsedToken?.token || savedToken;
                            } catch {
                                authToken.value = savedToken;
                            }
                        }
                    }
                    
                    // Auto-connect immediately
                    await connect();
                    
                    if (isConnected.value) {
                         if (params.has('service_id')) {
                            selectedServiceId.value = params.get('service_id');
                         } else {
                            // Try to find service automatically
                            await listServices();
                             // Auto-select logic is inside listServices now to handle async better
                         }
                         
                         if (params.has('view_session')) {
                             // Wait a bit for service to load
                             const sessId = params.get('view_session');
                             // We need to wait for watcher to fire
                             setTimeout(() => viewSession(sessId), 1000);
                         }
                    }
                });

                // --- Connection Methods ---
                const connect = async () => {
                    isConnecting.value = true;
                    autoConnectError.value = '';
                    try {
                        const config = { "server_url": serverUrl.value, method_timeout: 120000 };
                        if (authToken.value) config.token = authToken.value;
                        
                        const client = await hyphaWebsocketClient.connectToServer(config);
                        workspace.value = client?.config?.workspace || client?.workspace || '';
                        console.log('Connected server.config:', client?.config);
                        isConnected.value = true;
                        window.hyphaClient = client;
                        
                        // Initial Scan
                        await listServices();
                        
                    } catch (e) {
                        console.error(e);
                        autoConnectError.value = "Connection failed: " + (e.message || "Unknown error");
                        isConnected.value = false;
                    } finally {
                        isConnecting.value = false;
                    }
                };

                const login = async () => {
                    isConnecting.value = true;
                    autoConnectError.value = '';
                    try {
                        const loginResult = await hyphaWebsocketClient.login({
                            server_url: serverUrl.value,
                            profile: true,
                            login_callback: (context) => {
                                window.open(context.login_url, '_blank');
                            }
                        });
                        const token = typeof loginResult === 'string'
                            ? loginResult
                            : (loginResult?.token || loginResult?.tokenString || null);
                        if (token) {
                            authToken.value = token;
                            if (typeof loginResult === 'string') {
                                localStorage.setItem('hypha_token', token);
                            } else {
                                localStorage.setItem('hypha_token', JSON.stringify({
                                    tokenString: token,
                                    ...loginResult,
                                }));
                            }
                            await connect();
                        }
                    } catch (e) {
                         console.error(e);
                         autoConnectError.value = "Login failed: " + e.message;
                         isConnecting.value = false;
                    }
                };

                const disconnect = () => {
                    if (window.hyphaClient) window.hyphaClient.disconnect();
                    for (const [workspaceId, client] of Object.entries(workspaceClients)) {
                        if (client && client !== window.hyphaClient) {
                            try {
                                client.disconnect();
                            } catch (e) {
                                console.warn(`Failed to disconnect workspace client ${workspaceId}:`, e);
                            }
                        }
                        delete workspaceClients[workspaceId];
                    }
                    isConnected.value = false;
                    service.value = null;
                    sessions.value = {};
                };

                const listServices = async () => {
                    if (!window.hyphaClient) return;
                    isScanning.value = true;
                    try {
                        const client = window.hyphaClient;
                        const attemptList = [
                            () => client.listServices({ workspace: workspace.value || client?.config?.workspace }),
                            () => client.listServices(),
                            () => client.list_services({ workspace: workspace.value || client?.config?.workspace }),
                            () => client.list_services(),
                        ];

                        let listed = [];
                        for (const attempt of attemptList) {
                            try {
                                const result = await attempt();
                                if (Array.isArray(result)) {
                                    listed = result;
                                } else if (result && typeof result === 'object') {
                                    listed = Object.values(result);
                                }
                                if (listed.length > 0) break;
                            } catch (err) {
                                // Try next strategy
                            }
                        }

                        const serviceIds = listed
                            .map((entry) => {
                                if (!entry) return null;
                                if (typeof entry === 'string') return entry;
                                return entry.id || entry.service_id || null;
                            })
                            .filter(Boolean);

                        const cellposeIds = serviceIds.filter((id) => id.includes('cellpose-finetuning'));
                        availableServices.value = cellposeIds;

                        const preferredIds = [
                            `${workspace.value}/cellpose-finetuning`,
                            `${workspace.value}/cellpose-finetuning-test`,
                            `${workspace.value}/cellpose-finetuning-live`,
                            'ri-scale/cellpose-finetuning',
                            'ri-scale/cellpose-finetuning-test',
                            'bioimage-io/cellpose-finetuning',
                        ].filter(Boolean);

                        if (!availableServices.value.includes(selectedServiceId.value)) {
                            selectedServiceId.value = '';
                        }

                        if (!selectedServiceId.value && availableServices.value.length > 0) {
                            const preferred = preferredIds.find((id) => availableServices.value.includes(id));
                            selectedServiceId.value = preferred || availableServices.value[0];
                        }

                        if (availableServices.value.length === 0) {
                            for (const fallbackId of preferredIds) {
                                try {
                                    await client.getService(fallbackId);
                                    availableServices.value = [fallbackId];
                                    selectedServiceId.value = fallbackId;
                                    break;
                                } catch (_) {
                                    // try next fallback id
                                }
                            }
                        }

                        if (availableServices.value.length === 0) {
                            service.value = null;
                        }
                    } catch (e) {
                        console.warn("Service scan failed", e);
                    } finally {
                        isScanning.value = false;
                    }
                };

                // --- Helper: Get Artifact Manager ---
                const getArtifactManager = async () => {
                    return await window.hyphaClient.getService("public/artifact-manager");
                };

                // Watch Selected Service to Initialize
                watch(selectedServiceId, async (newId) => {
                    if (newId && window.hyphaClient) {
                        try {
                            service.value = await window.hyphaClient.getService(newId);
                            await refreshSessions();
                            startAutoUpdate();
                        } catch (e) {
                            console.error("Failed to bind service", e);
                            alert(`Failed to connect to service '${newId}': ${e.message}`);
                            service.value = null;
                        }
                    }
                });

                  // --- Dashboard Methods ---
                const refreshSessions = async (background = false) => {
                    if (!service.value) return;
                    if (refreshSessions._inFlight) {
                        if (background) return;
                        await refreshSessions._inFlight;
                        return;
                    }
                    if (!background) refreshLoading.value = true;
                    
                    refreshSessions._inFlight = (async () => {
                        try {
                            const result = await service.value.list_training_sessions();
                            
                            if (result) {
                                sessions.value = result;
                                syncError.value = null;

                                // Find active session
                                const running = Object.entries(sessions.value).find(([_, s]) => s && s.status_type === 'running');
                                if (running) {
                                    monitoringSessionId.value = running[0];
                                } else {
                                    monitoringSessionId.value = null;
                                }
                            }
                        } catch (e) {
                            console.error(e);
                            // Show sync error but preserve old sessions so user can see last known state
                            syncError.value = "Sync failed: " + (e.message || "Timeout") + ". Displayed data may be outdated.";
                        }
                    })();

                    try {
                        await refreshSessions._inFlight;
                    } finally {
                        refreshSessions._inFlight = null;
                        if (!background) refreshLoading.value = false;
                    }
                };

                let updateTimer = null;
                const startAutoUpdate = () => {
                    if (updateTimer) clearTimeout(updateTimer);
                    
                    const runLoop = async () => {
                        if (isConnected.value && service.value) {
                            try {
                                const shouldPollSessions = !isInferring.value && currentTab.value !== 'inference';
                                if (shouldPollSessions) {
                                    await refreshSessions(true);
                                    // If viewing a session, update charts
                                    if (currentTab.value === 'session_details' && selectedSessionId.value) {
                                        renderCharts();
                                    }
                                }
                            } catch (e) {
                                console.warn("Auto-update loop error:", e);
                                // If token expired, try to nudge user?
                                if (e.message && e.message.includes('expired')) {
                                    syncError.value = "Session expired. Please refresh page.";
                                    isConnected.value = false;
                                }
                            }
                        }
                        updateTimer = setTimeout(runLoop, 4000);
                    };
                    runLoop();
                };

                watch([currentTab, service, isConnected], async () => {
                    if (currentTab.value !== 'inference') return;
                    await nextTick();
                    const heading = document.querySelector('h2');
                    const headingText = heading ? heading.textContent : null;
                    const hasConfigCard = !!document.querySelector('h3');
                    const hasFileInput = !!document.querySelector('input[type="file"]');
                    console.info('[InferenceTab] render diagnostics', {
                        isConnected: isConnected.value,
                        hasService: !!service.value,
                        currentTab: currentTab.value,
                        headingText,
                        hasConfigCard,
                        hasFileInput,
                    });
                });

                const viewSession = (id) => {
                    if (!sessions.value[id]) return;
                    selectedSessionId.value = id;
                    currentTab.value = 'session_details';
                    setTimeout(renderCharts, 100);
                };

                // --- Data Formatting ---
                const statusTextColor = (status) => {
                    const map = { running: 'text-blue-600', completed: 'text-green-600', failed: 'text-red-600' };
                    return map[status] || 'text-gray-600';
                };
                
                const fromNow = (dateStr) => {
                    if (!dateStr) return '-';
                    return new Date(dateStr).toLocaleString();
                };
                
                const formatDuration = (seconds) => {
                    if (!seconds) return '-';
                    const h = Math.floor(seconds / 3600);
                    const m = Math.floor((seconds % 3600) / 60);
                    const s = Math.floor(seconds % 60);
                    return h > 0 ? `${h}h ${m}m ${s}s` : `${m}m ${s}s`;
                };
                
                const getLatestLoss = (session) => {
                    if (session.train_losses && session.train_losses.length > 0) {
                        return session.train_losses[session.train_losses.length - 1].toFixed(4);
                    }
                    return '-';
                };
                
                const formatDate = (iso) => iso ? new Date(iso).toLocaleDateString() + ' ' + new Date(iso).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '-';

                // --- Charting ---
                const renderCharts = () => {
                    if (!currentSession.value) return;
                    const s = currentSession.value;
                    const epochs = s.train_losses ? s.train_losses.map((_, i) => i + 1) : [];
                    
                    const layout = {
                        margin: { t: 20, r: 20, l: 40, b: 30 },
                        height: 280,
                        showlegend: true,
                        legend: { orientation: 'h', y: 1.1 },
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0)'
                    };

                    Plotly.react('lossChart', [
                        { x: epochs, y: s.train_losses || [], name: 'Train Loss', line: { color: '#3b82f6' } },
                        { x: epochs, y: s.test_losses || [], name: 'Val Loss', line: { color: '#f97316' } }
                    ], layout);

                    if (hasMetrics.value) {
                        const validEpochs = [];
                        const f1 = [];
                        const iou = [];
                        s.test_metrics.forEach((m, i) => {
                            if (m) { validEpochs.push(i + 1); f1.push(m.f1 || 0); iou.push(m.iou || 0); }
                        });
                        
                        Plotly.react('metricsChart', [
                            { x: validEpochs, y: f1, name: 'F1 Score', line: { color: '#10b981' } },
                            { x: validEpochs, y: iou, name: 'IoU', line: { color: '#8b5cf6' } }
                        ], layout);
                    }
                };

                // --- Actions ---
                const stopTraining = async (id) => {
                    if (!confirm("Stop this training session?")) return;
                    try { 
                        await service.value.stop_training({ session_id: id }, { _rkwargs: true }); 
                        if (sessions.value[id]) {
                            sessions.value[id].status_type = 'stopped';
                            sessions.value[id].message = 'Training session stopped by user.';
                        }
                        await refreshSessions(); 
                    }
                    catch (e) {
                        const errMsg = formatServiceError(e, 'Stop training');
                        trainingError.value = "Stop failed: " + errMsg;
                        syncError.value = "Stop failed: " + errMsg;
                        console.error("Stop training failed:", e);
                    }
                };

                const restartTraining = async (id) => {
                    try {
                        const result = await service.value.restart_training(
                            { session_id: id },
                            { _rkwargs: true }
                        );
                        if (result && result.session_id) {
                            sessions.value[result.session_id] = result;
                            monitoringSessionId.value = result.session_id;
                            viewSession(result.session_id);
                            await refreshSessions(true);
                            alert(`Training restarted. New session ID: ${result.session_id}`);
                        } else {
                            throw new Error(`Restart returned no session id: ${JSON.stringify(result)}`);
                        }
                    } catch (e) {
                        const errMsg = formatServiceError(e, 'Restart training');
                        trainingError.value = "Restart failed: " + errMsg;
                        syncError.value = "Restart failed: " + errMsg;
                        alert("Restart failed: " + errMsg);
                    }
                };

                const startTraining = async () => {
                    console.log("startTraining called");
                    isStartingTraining.value = true;
                    trainingError.value = '';
                    try {
                        const isBioImageArchive = trainingParams.dataset_source === 'BioImage Archive';
                        const hasMetadataDir = !!(trainingParams.metadata_dir && trainingParams.metadata_dir.trim());
                        const hasTrainImages = !!(trainingParams.train_images && trainingParams.train_images.trim());
                        const hasTrainAnnotations = !!(trainingParams.train_annotations && trainingParams.train_annotations.trim());

                        if (!isBioImageArchive && !hasMetadataDir && (!hasTrainImages || !hasTrainAnnotations)) {
                           throw new Error("Please provide either metadata folder or both train image and annotation paths.");
                        }
                        
                        // Determine the artifact value based on source
                            let artifactValue = trainingParams.artifact_input;
                        if (isBioImageArchive) {
                            artifactValue = trainingParams.bioimage_archive_url;
                            if (!artifactValue) throw new Error("Please enter a BioImage Archive URL.");
                        } else if (trainingParams.dataset_source === 'Upload') {
                                artifactValue = trainingParams.uploaded_artifact;
                             if (!artifactValue) throw new Error("Please upload a dataset first.");
                        } else {
                             if (!artifactValue) throw new Error("Please specify an Artifact ID.");
                        }

                        console.log("Invoking service.start_training with:", {
                            artifact: artifactValue,
                            train_images: isBioImageArchive ? null : (trainingParams.train_images || null),
                            train_annotations: isBioImageArchive ? null : (trainingParams.train_annotations || null),
                            metadata_dir: isBioImageArchive ? null : (trainingParams.metadata_dir || null),
                            split_mode: isBioImageArchive ? 'manual' : trainingParams.split_mode,
                            train_split_ratio: isBioImageArchive ? 0.8 : trainingParams.train_split_ratio,
                            test_images: (!isBioImageArchive && trainingParams.split_mode === 'manual') ? (trainingParams.test_images || null) : null,
                            test_annotations: (!isBioImageArchive && trainingParams.split_mode === 'manual') ? (trainingParams.test_annotations || null) : null,
                            model: trainingParams.model,
                            n_epochs: trainingParams.n_epochs,
                            learning_rate: trainingParams.learning_rate,
                            min_train_masks: trainingParams.min_train_masks
                        });
                        
                        console.log("Calling start_training with keyword args via _rkwargs.");
                        
                        const result = await service.value.start_training(
                            {
                                artifact: artifactValue,
                                train_images: isBioImageArchive ? null : (trainingParams.train_images || null),
                                train_annotations: isBioImageArchive ? null : (trainingParams.train_annotations || null),
                                metadata_dir: isBioImageArchive ? null : (trainingParams.metadata_dir || null),
                                split_mode: isBioImageArchive ? 'manual' : (trainingParams.split_mode || 'manual'),
                                train_split_ratio: isBioImageArchive ? 0.8 : Number(trainingParams.train_split_ratio || 0.8),
                                test_images: (!isBioImageArchive && trainingParams.split_mode === 'manual') ? (trainingParams.test_images || null) : null,
                                test_annotations: (!isBioImageArchive && trainingParams.split_mode === 'manual') ? (trainingParams.test_annotations || null) : null,
                                model: trainingParams.model || 'cpsam',
                                n_samples: null,
                                n_epochs: trainingParams.n_epochs,
                                learning_rate: trainingParams.learning_rate,
                                weight_decay: 1e-4,
                                min_train_masks: trainingParams.min_train_masks,
                                validation_interval: null
                            },
                            { _rkwargs: true }
                        );

                        console.log("start_training result:", result);
                        
                        if (result && result.session_id) {
                            // Update local session list immediately to ensure viewSession finds it
                            sessions.value[result.session_id] = result;
                            
                            monitoringSessionId.value = result.session_id;
                            viewSession(result.session_id);
                            
                            // Trigger background refresh
                            refreshSessions(true);
                            
                            alert("Training started successfully! Session ID: " + result.session_id);
                        } else {
                            throw new Error("No session_id returned: " + JSON.stringify(result));
                        }
                    } catch (e) {
                        console.error("Start Training Error:", e);
                        const errMsg = formatServiceError(e, 'Training');
                        trainingError.value = "Start failed: " + errMsg;
                        alert("Start Training Failed:\n" + errMsg);
                    } finally {
                        isStartingTraining.value = false;
                    }
                };


                const handleFolderSelect = (event) => {
                     const files = event.target.files;
                     if (files && files.length > 0) {
                         // Generate a readable alias
                         const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                         const rand = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
                         uploadParams.alias = `dataset-${date}-${rand}`;
                     }
                };

                // --- Upload ---
                const uploadDataset = async () => {
                   if (!folderInput.value.files.length) return;
                   
                   // Ensure alias is present
                   if (!uploadParams.alias) {
                       const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                       const rand = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
                       uploadParams.alias = `dataset-${date}-${rand}`;
                   }

                   isUploading.value = true;
                   uploadStatus.value = "Initializing...";
                   
                   try {
                        const am = await getArtifactManager();
                        const alias = uploadParams.alias;
                        
                        // Use explicit manifest arg
                        const manifest = {
                            alias: alias,
                            type: "dataset",
                            stage: true
                        };
                        console.log("Creating artifact with manifest:", manifest);
                        
                        // Pass manifest as positional args to match Hypha signature:
                        // create(alias, artifact_id, workspace, parent_id, manifest, type, config, secrets, version, comment, overwrite, stage, context)
                        const artifact = await am.create({
                            alias: alias,
                            workspace: getUserWorkspace(),
                            manifest: manifest,
                            type: "dataset",
                            overwrite: true,
                            stage: true,
                            _rkwargs: true
                        });
                        
                        const files = Array.from(folderInput.value.files);
                        let completed = 0;
                        uploadStatus.value = `Uploading ${files.length} files...`;

                        // Simple concurrency control (batches of 5)
                        const batchSize = 5;
                        for (let i = 0; i < files.length; i += batchSize) {
                            const batch = files.slice(i, i + batchSize);
                            await Promise.all(batch.map(async (file) => {
                                const path = file.webkitRelativePath || file.name;
                                const putUrl = await am.put_file(artifact.id, path);
                                await fetch(putUrl, { method: 'PUT', body: file });
                                completed++;
                                uploadProgress.value = Math.round((completed / files.length) * 100);
                            }));
                        }
                        
                        uploadStatus.value = "Committing...";
                        await am.commit(artifact.id);
                        
                        // Set fields in form
                        trainingParams.uploaded_artifact = artifact.id;
                        showUploadModal.value = false;
                        alert(`Dataset '${artifact.id}' uploaded successfully!`);
                        
                    } catch (e) {
                        console.error(e);
                        alert("Upload error: " + e.message);
                    } finally {
                        isUploading.value = false;
                    }
                };

                // --- Inference ---
                const toUint8Channel = (typedArray) => {
                    if (!typedArray || typedArray.length === 0) return new Uint8Array();
                    let min = Infinity;
                    let max = -Infinity;
                    for (let i = 0; i < typedArray.length; i++) {
                        const v = typedArray[i];
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    if (!Number.isFinite(min) || !Number.isFinite(max)) return new Uint8Array(typedArray.length);
                    const out = new Uint8Array(typedArray.length);
                    if (max <= 255 && min >= 0) {
                        for (let i = 0; i < typedArray.length; i++) out[i] = typedArray[i];
                        return out;
                    }
                    const range = max - min || 1;
                    for (let i = 0; i < typedArray.length; i++) {
                        out[i] = Math.max(0, Math.min(255, Math.round(((typedArray[i] - min) / range) * 255)));
                    }
                    return out;
                };

                const makePngFromChannels = (width, height, channels) => {
                    const r = toUint8Channel(channels[0] || channels[0]);
                    const g = toUint8Channel(channels[1] || channels[0]);
                    const b = toUint8Channel(channels[2] || channels[0]);
                    const rgba = new Uint8ClampedArray(width * height * 4);
                    for (let i = 0; i < width * height; i++) {
                        const idx = i * 4;
                        rgba[idx] = r[i] ?? 0;
                        rgba[idx + 1] = g[i] ?? 0;
                        rgba[idx + 2] = b[i] ?? 0;
                        rgba[idx + 3] = 255;
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    const imageData = new ImageData(rgba, width, height);
                    ctx.putImageData(imageData, 0, 0);
                    return canvas.toDataURL('image/png');
                };

                const createTiffPreviewGeoTiff = async (buffer) => {
                    if (!window.GeoTIFF) throw new Error('GeoTIFF decoder unavailable');
                    const tiff = await window.GeoTIFF.fromArrayBuffer(buffer);
                    const image = await tiff.getImage();
                    const width = image.getWidth();
                    const height = image.getHeight();
                    if (!width || !height) throw new Error('Invalid TIFF dimensions');
                    const rasters = await image.readRasters({ interleave: false });
                    if (!rasters || rasters.length === 0) throw new Error('No TIFF raster channels found');
                    const channels = [rasters[0], rasters[1] || rasters[0], rasters[2] || rasters[0]];
                    return makePngFromChannels(width, height, channels);
                };

                const createTiffPreview = async (file) => {
                    const buffer = await file.arrayBuffer();
                    try {
                        return await createTiffPreviewGeoTiff(buffer);
                    } catch (geoError) {
                        console.warn('GeoTIFF preview decode failed, trying UTIF fallback:', geoError);
                    }

                    const ifds = UTIF.decode(buffer);
                    if (!ifds || ifds.length === 0) {
                        throw new Error("No TIFF image frames found.");
                    }
                    UTIF.decodeImage(buffer, ifds[0]);
                    const rgba = UTIF.toRGBA8(ifds[0]);
                    const width = ifds[0].width;
                    const height = ifds[0].height;

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    const imageData = new ImageData(new Uint8ClampedArray(rgba), width, height);
                    ctx.putImageData(imageData, 0, 0);
                    return canvas.toDataURL('image/png');
                };

                const handleInferenceFile = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        inferenceFile.value = file;
                        const lowerName = (file.name || '').toLowerCase();
                        const isTiff = lowerName.endsWith('.tif') || lowerName.endsWith('.tiff');

                        try {
                            if (isTiff) {
                                inferencePreview.value = await createTiffPreview(file);
                            } else {
                                inferencePreview.value = URL.createObjectURL(file);
                            }
                        } catch (previewError) {
                            console.warn('TIFF preview decode failed, falling back to object URL:', previewError);
                            inferencePreview.value = URL.createObjectURL(file);
                        }

                        inferenceResult.value = null; // Reset previous result
                        
                        // Reset canvas
                        const canvas = inferenceCanvas.value;
                        if (canvas) {
                             const ctx = canvas.getContext('2d');
                             ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }
                };

                const syncOverlayToPreview = () => {
                    const img = previewImg.value;
                    const canvas = inferenceCanvas.value;
                    if (!img || !canvas) return;

                    const displayedWidth = img.clientWidth || img.naturalWidth;
                    const displayedHeight = img.clientHeight || img.naturalHeight;

                    canvasStyle.left = `${img.offsetLeft}px`;
                    canvasStyle.top = `${img.offsetTop}px`;
                    canvasStyle.width = `${displayedWidth}px`;
                    canvasStyle.height = `${displayedHeight}px`;

                    if (!canvas.width || !canvas.height) {
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                    }
                };

                const onImageLoad = () => {
                    const img = previewImg.value;
                    const canvas = inferenceCanvas.value;
                    if (img && canvas) {
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        syncOverlayToPreview();
                    }
                };

                const runInference = async () => {
                    if (!inferenceFile.value) return;
                    isInferring.value = true;
                    inferenceResult.value = null;
                    inferenceObjectCount.value = 0;
                    console.log("Starting inference...");
                    try {
                        const am = await getArtifactManager();
                        
                        // Upload temp file
                        const tmpAlias = `inference-${Date.now()}`;
                        const manifest = { 
                            alias: tmpAlias, 
                            type: "temp", 
                            stage: true, 
                            expires_after: 1800,
                            visibility: "public"
                        };
                        
                        console.log("Creating temp artifact:", tmpAlias);
                        const art = await am.create({
                            alias: tmpAlias,
                            manifest: manifest,
                            workspace: getServiceWorkspace() || getUserWorkspace(),
                            config: { permissions: { "*": "r" } },
                            type: "temp",
                            stage: true,
                            overwrite: true,
                            _rkwargs: true,
                        });
                        
                        const fname = inferenceFile.value.name;
                        const url = await am.put_file(art.id, fname);
                        console.log("Uploading file to:", url);
                        await fetch(url, { method: 'PUT', body: inferenceFile.value });
                        await am.commit(art.id); // Commit required for reading
                        
                        console.log("Invoking service.infer with keyword args via _rkwargs.");

                        const result = await service.value.infer(
                            {
                                artifact: art.id,
                                image_paths: [fname],
                                input_arrays: null,
                                model: inferenceParams.model,
                                diameter: inferenceParams.diameter || null,
                                flow_threshold: 0.4,
                                cellprob_threshold: 0.0,
                                niter: null,
                                return_flows: false,
                                json_safe: true
                            },
                            { _rkwargs: true }
                        );
                        
                        console.log("Inference Raw Result:", result);

                        if (result && result.length > 0) {
                             // Deep copy the result to detach from any proxies
                             try {
                                 inferenceResult.value = JSON.parse(JSON.stringify(result[0]));
                             } catch(e) {
                                 console.warn("Failed to structured clone result, using direct assignment", e);
                                 inferenceResult.value = result[0];
                             }
                             drawInference(inferenceResult.value.output);
                        } else {
                            throw new Error("No inference result returned from service (empty list or null).");
                        }
                        
                    } catch (e) {
                        console.error("Inference Error:", e);
                        alert("Inference fail: " + formatServiceError(e, 'Inference'));
                    } finally {
                        isInferring.value = false;
                    }
                };

                const drawInference = (mask) => {
                    const canvas = inferenceCanvas.value;
                    if (!canvas || !mask) return;
                    syncOverlayToPreview();

                    if (typeof mask === 'object' && mask.encoding === 'mask_png_base64' && mask.png_base64) {
                        const width = Number(mask.width || 0);
                        const height = Number(mask.height || 0);
                        if (width > 0 && height > 0) {
                            canvas.width = width;
                            canvas.height = height;
                        }
                        inferenceObjectCount.value = Number(mask.object_count || 0);
                        const ctx = canvas.getContext('2d');
                        const img = new Image();
                        img.onload = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        };
                        img.src = `data:image/png;base64,${mask.png_base64}`;
                        return;
                    }

                    const mask2d = to2DMaskArray(mask);
                    if (!mask2d) {
                        throw new Error('Inference returned a mask payload that the UI cannot render.');
                    }

                    const height = mask2d.length;
                    const width = mask2d[0]?.length || 0;
                    if (!width || !height) {
                        throw new Error('Inference returned an empty mask.');
                    }

                    if (canvas.width !== width || canvas.height !== height) {
                        canvas.width = width;
                        canvas.height = height;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    
                    // Simple pixel manipulation
                    const idata = ctx.createImageData(width, height);
                    const data = idata.data;
                    
                    // Handle nested array [y][x] or flat
                    const flatData = mask2d.flat();
                    inferenceObjectCount.value = Math.max(0, new Set(flatData).size - 1);

                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const row = mask2d[y];
                            const val = Array.isArray(row) ? row[x] : 0;

                            if (val && val > 0) {
                                const idx = (y * width + x) * 4;
                                // Simple hash for color
                                const r = (val * 123) % 255;
                                const g = (val * 231) % 255;
                                const b = (val * 73) % 255;
                                
                                data[idx] = r;
                                data[idx+1] = g;
                                data[idx+2] = b;
                                data[idx+3] = 150; // alpha
                            }
                        }
                    }
                    ctx.putImageData(idata, 0, 0);
                };

                // --- File Browser ---
                const openFileBrowser = async () => {
                   const selectedArtifactId = getSelectedArtifactId();
                   if (!selectedArtifactId) {
                       alert("Please enter an Artifact ID first (e.g. from the dashboard or your workspace).");
                       return;
                   }
                   showFileBrowser.value = true;
                   browserPath.value = '';
                   browserError.value = '';
                   browserFiles.value = [];
                   Object.keys(browserPathTypes).forEach((k) => delete browserPathTypes[k]);
                   browserLoading.value = true;
                   
                   try {
                       const am = await getArtifactManager();
                       
                       // Try detailed read
                       try {
                            // If navigation path is empty, we read the root
                            // If we are navigating INTO a folder, we might need to list files recursively or fetch the folder content?
                            // But usually `am.read` or `list_files` returns ALL files?
                            // If it returns a shallow list (folders only), we have a problem.
                            // Let's assume `list_files` handles recursive listing unless specified otherwise.
                            
                            // ISSUE: The initial list seemed to be shallow ("images", "annotations").
                            // If `browserFiles` only has directories, we can't show files inside them.
                            // We need to re-fetch if the user drills down, OR we need to ensure we fetch everything up front.
                            // `am.list_files` usually returns all files.
                            // If "images" is a folder, `list_files` on it?
                            
                           let rawFiles = [];
                           // Use list_files directly to get a flat list of strings
                           // Note: list_files might not be recursive by default in some implementations?
                           // Actually hypha artifact manager list_files usually returns all keys.
                           
                           // However, if we are in a subfolder, maybe we should fetch for that subfolder?
                           // But `browserFiles` is the state for the whole tree currently.
                           // Let's optimize: When opening browser, fetch EVERYTHING.
                           
                           console.log("Fetching file list for artifact:", selectedArtifactId);
                           rawFiles = await am.list_files(selectedArtifactId);
                           
                           // If rawFiles is just ["images", "annotations"], that means the artifact
                           // literally only contains those entries (maybe as empty file placeholders for folders?)
                           // OR the artifact manager is returning directories.
                           
                        
                        // Fallback: If list_files didn't work as expected or returned empty
                        if (!rawFiles || rawFiles.length === 0) {
                            console.log("list_files returned empty, trying to read manifest directly...");
                            const art = await am.read(selectedArtifactId);
                            if (art.manifest && art.manifest.files) {
                                rawFiles = art.manifest.files;
                            } else if (art.files) {
                                rawFiles = art.files;
                            }
                        }
                        
                        // Handle cases where start_training is missing (debugging)
                        if (service.value && typeof service.value.start_training !== 'function') {
                            console.warn("WARNING: start_training method is missing on service object!", service.value);
                            // Try to re-bind or check keys
                            console.log("Service keys:", Object.keys(service.value));
                        }
                           
                           browserFiles.value = rawFiles.map(f => {
                            // Handle object format {name: "...", ...} or string
                            let p = typeof f === 'string' ? f : (f.path || f.name || f.key || "");
                            // Remove leading ./ or /
                            return p.replace(/^\.?\//, '');
                        }).filter(f => f && typeof f === 'string');

                        const detectPathType = async (pathStr) => {
                            const normalizedPath = String(pathStr || '').replace(/^\.?\//, '').replace(/\/$/, '');
                            if (!normalizedPath) return;

                            try {
                                const listed = await am.list_files(selectedArtifactId, normalizedPath);
                                if (Array.isArray(listed) && listed.length > 0) {
                                    browserPathTypes[normalizedPath] = 'folder';
                                    return;
                                }
                            } catch (_e) {
                                // Ignore and try other heuristics
                            }

                            if (browserPathTypes[normalizedPath] !== 'folder') {
                                browserPathTypes[normalizedPath] = 'file';
                            }
                        };

                        await Promise.all(browserFiles.value.slice(0, 200).map((pathStr) => detectPathType(pathStr)));
                            
                        console.log("Loaded browser files:", browserFiles.value.length, browserFiles.value.slice(0, 10));

                       } catch (e) {
                           throw e;
                       }
                   } catch (e) {
                       console.error(e);
                       browserError.value = "Failed to load artifact: " + e.message;
                   } finally {
                       browserLoading.value = false;
                   }
                };


                // Watch browserPath to refetch if needed
                watch(browserPath, async (newPath) => {
                     if (!newPath) return;
                     
                     // Check if we already have content for this path
                     // browserVisibleItems is computed based on browserFiles.
                     // If we have items in browserFiles that start with "newPath/", we are good.
                     // However, browserVisibleItems is not available here synchronously if computed? 
                     // Actually we can check browserFiles directly.
                     
                     const start = newPath.endsWith('/') ? newPath : newPath + '/';
                     const hasContent = browserFiles.value.some(f => f.startsWith(start));
                     
                     if (!hasContent) {
                         // Likely a placeholder folder. Try to fetch contents.
                         // Use local loading state for just this check?
                         // Or reuse browserLoading if we want to block UI. Use simpler indicators.
                         console.log(`Path ${newPath} seems empty locally. Fetching...`);
                         
                         try {
                             const am = await getArtifactManager();
                             // Fetch files in this directory. 
                             // NOTE: list_files(artifact_id, dir_path=...) might be supported depending on version.
                             // Attempting to pass dir_path as 2nd argument.
                             // Signature: list_files(artifact_id, dir_path, limit, version, stage, include_pending, offset, context)
                             
                             // If the API supports it, this will fill the gap.
                             // Some AM versions treat 2nd arg as context? No, Python sig says dir_path.
                             // JS Client typically maps args.
                             let newFiles = [];
                             try {
                                 // Try positional: list_files(id, path)
                                 newFiles = await am.list_files(getSelectedArtifactId(), newPath);
                             } catch (err) {
                                 console.warn("list_files(id, path) failed. Trying without path filtering or keyword args if object", err);
                             }
                             
                             if (newFiles && newFiles.length > 0) {
                                 const p = newPath.endsWith('/') ? newPath : newPath + '/';
                                 // Add files if they aren't already there
                                 const existing = new Set(browserFiles.value);
                                 let added = 0;
                                 
                                 for (let f of newFiles) {
                                     // f might be relative to artifact root, or relative to dir_path?
                                     // Typically relative to root.
                                     let pathStr = typeof f === 'string' ? f : (f.path || f.name || f.key || "");
                                     pathStr = pathStr.replace(/^\.?\//, '');
                                     
                                     // Fix: If it's a basename (doesn't start with newPath), prepend newPath
                                     // We assume if we asked for a dir, we got children of that dir
                                     if (newPath && !pathStr.startsWith(newPath)) {
                                         pathStr = (newPath.endsWith('/') ? newPath : newPath + '/') + pathStr;
                                     }
                                     
                                     // Ensure format consistency
                                     if (pathStr && !existing.has(pathStr)) {
                                         browserFiles.value.push(pathStr);
                                         added++;
                                     }

                                     const normalizedPath = String(pathStr || '').replace(/\/$/, '');
                                     if (normalizedPath) {
                                         try {
                                             const listed = await am.list_files(getSelectedArtifactId(), normalizedPath);
                                             if (Array.isArray(listed) && listed.length > 0) {
                                                 browserPathTypes[normalizedPath] = 'folder';
                                             } else if (browserPathTypes[normalizedPath] !== 'folder') {
                                                 browserPathTypes[normalizedPath] = 'file';
                                             }
                                         } catch (_e) {
                                             if (browserPathTypes[normalizedPath] !== 'folder') {
                                                 browserPathTypes[normalizedPath] = 'file';
                                             }
                                         }
                                     }
                                 }
                                 console.log(`Fetched ${added} new items for ${newPath}`);
                             }
                         } catch (e) {
                             console.error("Failed to fetch sub-path:", e);
                         }
                     }
                });
                
                // Feedback for browser actions
                const browserFeedback = ref('');
                
                const showBrowserFeedback = (msg) => {
                    browserFeedback.value = msg;
                    setTimeout(() => browserFeedback.value = '', 2000);
                };

                const browserVisibleItems = computed(() => {
                    if (!browserFiles.value) return [];
                    
                    const p = browserPath.value ? (browserPath.value.endsWith('/') ? browserPath.value : browserPath.value + '/') : '';
                    const items = new Map();

                    for (const f of browserFiles.value) {
                         // Skip if not in current path
                         if (p && !f.startsWith(p)) continue;
                         
                         // Get relative path
                         const rel = f.slice(p.length);
                         if (!rel) continue; // Same path as folder
                         
                         // Get first component
                         const parts = rel.split('/');
                         const name = parts[0];
                         
                         // If it has deeper parts, it's a folder
                         // Or if it ends with slash (though split might handle empty last part)
                         // logic: "subdir/file.txt" -> parts=["subdir", "file.txt"] -> name="subdir"
                         // logic: "file.txt" -> parts=["file.txt"] -> name="file.txt"
                         
                         if (parts.length > 1 && parts[1] !== "") {
                             // It is a directory containing stuff
                             if (!items.has(name)) {
                                 const fullPath = (p + name).replace(/\/$/, '');
                                 browserPathTypes[fullPath] = 'folder';
                                 items.set(name, { name, type: 'folder', fullPath });
                             }
                         } else {
                             // It is a file or empty directory placeholder
                             // If name ends with slash in original? No we stripped them in loading.
                             // Check if it's a file
                             if (!items.has(name)) {
                                const isExplicitFolder = f.endsWith('/');
                                const fullPath = (p + name).replace(/\/$/, '');
                                const knownType = browserPathTypes[fullPath];
                                items.set(name, { 
                                    name, 
                                    type: knownType || (isExplicitFolder ? 'folder' : 'file'), 
                                    fullPath
                                });
                             }
                         }
                    }

                    // Heuristic fallback only when type is still unknown
                    for (const [name, item] of items) {
                        if (!browserPathTypes[item.fullPath] && item.type === 'file' && !name.includes('.')) {
                             if (['images', 'annotations', 'masks', 'models', 'data', 'train', 'test', 'val'].includes(name.toLowerCase())) {
                                 item.type = 'folder';
                                 browserPathTypes[item.fullPath] = 'folder';
                             }
                        }
                    }
                    
                    return Array.from(items.values()).sort((a, b) => {
                        if (a.type === b.type) return a.name.localeCompare(b.name);
                        return a.type === 'folder' ? -1 : 1;
                    });
                });
                
                const browserNavigate = (fullPath) => {
                    console.log("Navigating to:", fullPath);
                    browserPath.value = fullPath.replace(/\/$/, "");
                };

                        // Handle item click
                        const handleItemClick = (item) => {
                            if (item.type === 'folder') {
                                // Navigate into folder
                                browserPath.value = item.fullPath;
                            }
                        };
                        
                        const browserNavigateUp = () => {
                            if (!browserPath.value) return;
                            const parts = browserPath.value.split('/');
                            parts.pop();
                            browserPath.value = parts.join('/');
                        };
                        
                        const selectFolderFor = (path, target) => {
                             let val = path ? (path.endsWith('/') ? path : path + '/') : '';
                             
                             // QoL: Append default patterns
                             if (target === 'images') {
                                 val += '*.tif';
                                 trainingParams.train_images = val;
                             } else if (target === 'annotations') {
                                 val += '*_mask.ome.tif';
                                 trainingParams.train_annotations = val;
                             }
                             
                             // Show feedback
                             if (typeof showBrowserFeedback === 'function') {
                                 showBrowserFeedback(`Selected "${val}"`);
                             } else {
                                 browserFeedback.value = `Selected "${val}"`;
                                 setTimeout(() => browserFeedback.value = '', 2000);
                             }
                        };

                // --- Export ---
                const exportModel = async () => {
                    isExporting.value = true;
                    try {
                        if (!selectedSessionId.value) {
                            throw new Error('Select a completed session before exporting.');
                        }
                        const latestStatus = await service.value.get_training_status(
                            { session_id: selectedSessionId.value },
                            { _rkwargs: true }
                        );
                        if (!latestStatus || latestStatus.status_type !== 'completed') {
                            throw new Error(`Session ${selectedSessionId.value} is '${latestStatus?.status_type || 'unknown'}'. Wait for completion and retry.`);
                        }

                        exportResult.value = await service.value.export_model(
                            {
                                session_id: selectedSessionId.value,
                                model_name: exportModelName.value || null,
                                collection: 'bioimage-io/colab-annotations' // Default collection
                            },
                            { _rkwargs: true }
                        );
                    } catch (e) {
                         alert("Export failed: " + e.message);
                    } finally {
                        isExporting.value = false;
                    }
                };

                return {
                    syncError, trainingError, handleItemClick,
                    serverUrl, isConnected, isConnecting, workspace, showTokenInput, authToken, autoConnectError,
                    availableServices, selectedServiceId, service, isScanning, listServices, disconnect, connect, login,
                    currentTab, tabs,
                    sessions, refreshSessions, refreshLoading, monitoringSessionId, monitoredSession, selectedSessionId, viewSession, currentSession, hasMetrics, hasValidationSet, stopTraining, restartTraining,
                    runningTrainingSessionsCount,
                    trainingParams, startTraining, isStartingTraining,
                    applyTrainingGlobExample, applyTrainingFolderExample,
                    showUploadModal, uploadParams, uploadDataset, isUploading, uploadProgress, uploadStatus, folderInput,
                    inferenceParams, pretrainedModels, inferenceFile, handleInferenceFile, inferencePreview, isInferring, runInference, inferenceCanvas, previewImg, onImageLoad, canvasStyle, inferenceObjectCount, inferenceResult,
                    exportModelName, isExporting, exportResult, exportModel,
                    
                    // File Browser
                    showFileBrowser, openFileBrowser, browserFiles, browserPath, browserLoading, browserError,
                    browserVisibleItems, browserNavigate, browserNavigateUp, selectFolderFor, browserFeedback,

                    // Autocomplete
                    suggestions, showSuggestions, artifactInputError, artifactIdExists, artifactLookupPending, handleArtifactInput, selectSuggestion, acceptSuggestion, closeSuggestions,

                    // Helpers
                    statusTextColor, formatDuration, handleFolderSelect, getLatestLoss, formatDate, getSelectedArtifactId,
                };
            }
        });
        app.config.compilerOptions.delimiters = ['[[', ']]'];
        app.mount('#app');
    </script>
</body>
</html>